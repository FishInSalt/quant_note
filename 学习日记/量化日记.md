# 量化日记

AI引导法则：
（类似如何跟人一样沟通实现功能需求）
1、想清楚自己希望实现一个怎样的功能。
    1.1、属于常见功能：自己有个初步方案，然后让AI给方案，并对比优劣
    1.2、属于不常见功能：在AI的辅助下形成初步方案
2、跟AI讨论实现细节，严格规范标准，形成严谨详细的方案文档
3、让AI根据详细方案文档，准确地实现该功能
4、AI补充用例测试
5、功能调整和验收


日常leetcode刷题，保持手感

## 2026/01/12

参数优化 freqtrade hyperopt
1、运行逻辑：计算指标，计算入场信号和出场信号，回测得到结果，然后将结果传到损失函数，通过hyperopt算法计算下一批参数组
2、默认参数下，首次计算所有参数组的指标存到内存，后续按需获取，优化时间短但内存占用高。通过--analyze-per-epoch，每次回测只计算所需指标。内存占用低但计算时间长
3、可以优化参数默认分为多个类别，比如buy、sell、enter等，也可以自定义类别。这些类别在运行freqtrade hyperopt时通过--space指定，用于每次只优化特定类别的参数，以降低参数优化空间。
4、参数优化类型：IntParameter整数类型、DecimalParameter小数类型、CategoricalParameter枚举类型、BooleanParameter布尔类型
5、参数优化类型的对象在创建时可以传入optimize=false，表示该参数不优化；load=false表示不加载先前hyperopt的运行结果
6、损失函数：内置了多种损失函数，也可以自定义损失函数
7、当参数搜索空间巨大时，参数优化迭代所需时间会很长，推荐使用screen或者tmux命令来保持命令不中断


在阿里云服务器上运行freqtrade dry-run模式，

下一步问AI：结合项目的代码，从程序启动到UI显示图表，freqtrade执行了哪些逻辑（启动如何加载配置、如何同步交易对数据，如何执行策略，如何在UI上显示这些数据），请给我一份代码执行顺序图，以便我快速掌握freqtrade从项目启动，到数据加载，执行策略，并将交易过程显示到UI中的这整个过程。


## 2026/01/09

回测命令 freqtrade backtesting 
1、回测的历史数据需要预先通过freqtrade download-data下载，具体见 freqtrade download-data命令
1、回测配置中，dry_run_wallet必须比stake_amount高
2、不同回撤场景下的命令
    2.1、普通场景：freqtrade backtesting --strategy AwesomeStrategy。用5m k线图回测AwesomeStrategy
    2.2、指定timeframe：freqtrade backtesting --strategy AwesomeStrategy --timeframe 1m
    2.3、指定回测的钱包资金：freqtrade backtesting --strategy AwesomeStrategy --dry-run-wallet 1000
    2.4、指定回测数据：freqtrade backtesting --strategy AwesomeStrategy --datadir user_data/data/binance-20180101
    2.5、回测多个策略：freqtrade backtesting --strategy-list SampleStrategy1 AwesomeStrategy --timeframe 5m
    2.6、指定手续费：freqtrade backtesting --fee 0.001
    2.7、指定回测时间段：freqtrade backtesting --timerange=20190501-
    2.8、按日度、周度、月度、年度查看回测结果概览：freqtrade backtesting --strategy MyAwesomeStrategy --breakdown month year
3、回测结果表格解析，表格中各个指标的意义
4、回测结果默认会缓存，要强制不使用缓存，加参数--cache none
5、回测输出文件中的zip文件包含如下文件：回测报告、回测数据、策略、策略参数、配置文件。用于复现回测结果
6、回测交易的一些假设
    6.1、遵守交易所的所有限制
    6.2、入场订单会以开盘价执行，除非策略中有设定价格
    6.3、只要订单的特定价格在当前蜡烛图的最高/最低价范围内，订单就会成交
    6.4、出场信号默认以下一个蜡烛图的开盘价出场
    6.5、卖出信号执行优先级比止损要高，因为卖出信号触发在开盘时
    6.7、一个蜡烛图中，策略先经过最低价确定是否止损然后到最高价止盈，以最大程度保护资金
    6.8、类似，策略在一个蜡烛图中先计算止损场景再计算ROI收益率场景。
    6.9、追踪止损，先根据最高价确定新的追踪止损价，然后最低价低于追踪止损价则触发止损，不调整追踪止损价，否则调整追踪止损价。注意ROI的止盈操作要优先追踪止损
    6.10、总结在同一个蜡烛图中存在多种出场信号，策略出场执行顺序：退出信号、止损、ROI止盈、追踪止损
7、**在回测通过假如更小timeframe来模拟实战运行时的价格波动，提升回测准确度**：freqtrade backtesting --strategy AwesomeStrategy --timeframe 1h --timeframe-detail 5m

## 2026/01/08

数据下载命令freqtrade download-data
1、用于**回测和参数优化**
2、数据形式有trade数据和ohlcv两种形式，trade(交易)数据粒度比较细，比如每秒的交易详情（成交价，成交量，订单簿数据），可以理解为回测中的实时数据（tick级数据）；ohlcv则是k线图数据
3、--timeframes、--timerange 指定时间周期（timeframe）和时间段（timerange），默认下载30day内的1m和5m数据
4、--exchange指定交易所，参数指定或者配置文件指定
5、本地数据存储格式指定，默认feather格式，可选json等格式
6、--data-format-ohlcv、--data-format-trades指定k线图类型，现货、合约、资金费率
7、--tradingmode，指定交易模式，现货、margin(现货杠杆)、合约

开通阿里的香港云服务器，初始化freqtrade环境
1、用阿里云国际版的香港云服务器需要更新源为国外原生源http://archive.ubuntu.com/ubuntu/
1、安装docker，https://www.cnblogs.com/carmi/p/17939025
2、通过docker安装freqtrade
3、运行freqtrade


## 2026/01/07
控制freqtrade bot的方式
1、telegram，配置telegram可以通过聊天机器人查看、控制当前的交易状态
2、FreqUI，默认安装，freqtrade trade命令在运行交易机器人的同时拉起freqUI与交易机器人交互，freqtrade webserver命令则用于拉起freqUI，对策略进行回测 
3、Rest API，调freqtrade交易机器人提供的http API接口进行交互，工具有curl或者 freqtrade-client
4、webhook，通过配置，当情况触发时自动向某个url发送http请求，比如IFTTT、discord聊天软件这些服务

## 2026/01/06
止损机制
1、stoploss_on_exchange，止损模式分为在交易所内止损和在交易所外止损，通过设置该参数为True/False
2、在交易所内止损时指买入订单完成时，立即在交易所挂出一个对应的止损限价单。这样可以避免市场崩溃带来的影响。
3、stoploss_on_exchange_interval，止损单会定时更新，但定时频率与循环工作流（一般5s跑一次）不同，默认1m检查并更新一次，防止频率太快被交易所ban掉
4、止损类型：
    4.1、static stop loss，静态止损，低于某个止损价全部平仓
    4.2、trailing stop loss，追踪止损，低于max(当前价，最高价)*(1-止损率)时平仓，止损价只会不断提高（如果资产价格上涨）
    4.3、Trailing stop loss, different positive loss，追踪止损，在盈利时设置不同止损
5、止损与杠杆：止损只关注交易者实际损失是否达到下注额的止损率，因此加杠杆会缩小触发止损所需的市场波动（10倍杠杆，-10%止损，只需市场1%波动即触发）
6、可以通过修改配置后，重新启动bot的方式修改止损价（一种情况除外：追踪止损触发，止损价已设置成更高的价位）



筛选交易对的方式，用于筛选符合交易条件的交易对
1、StaticPairList，静态筛选，按配置中的交易对白名单和黑名单筛选
2、VolumePairList，按成交额筛选
3、PercentChangePairList，根据波动率筛选，可以按涨跌幅筛选强势或者弱势的币种
4、ProducerPairList，从生产者筛选交易对，用于跨机器人交易，保证不同机器人之间的交易对一致
5、RemotePairList，从远程服务器筛选交易对，
6、MarketCapPairList，市值交易对，从CoinGecko返回币种市值排行，然后筛选
7、AgeFilter，筛选上市少于/超过多少天的交易对
8、DelistFilter，筛选超过多久时间后下架的交易对
9、FullTradesFilter，当开仓数达到设置上限，只留下开仓的交易对
10、OffsetFilter，根据偏移筛选交易对
11、PerformanceFilter，根据交易对的历史表现筛选，建议数据库中已有100多的交易历史记录
12、PrecisionFilter，过滤低价格的交易对
13、PriceFilter，根据价格区间过滤交易对
14、ShuffleFilter，对已过滤的交易对进行洗牌，用于平均每个符合条件的交易对的交易频率
15、SpreadFilter，过滤买卖差价超过某个比率的交易对
16、RangeStabilityFilter，通过计算一段时间的最高最低价差过滤交易对
17、VolatilityFilter，通过波动率过滤交易对（效果类似RangeStabilityFilter，但计算方式不同）

protections保护机制：
1、止损守卫，在特定时间窗口内发生指定次数的止损后，停止交易。
2、最大回撤，当最大回撤达到设定值时，停止交易。
3、低收益率交易对，锁定利润较低的交易对。
4、冷却期，在卖出交易后的一段时间内禁止开新仓。

## 2026/01/05
实现策略时提供的几个回调函数：
1、bot_loop_start，循环工作流的第一个动作
2、custom_stake_amount，开仓前回调，确认仓位
3、custom_exit，自定义退出逻辑，每次循环处理未平仓的交易时会调用
4、custom_stoploss，自定义止损，每次循环处理未平仓的交易时会调用，止损值（非止损价）只能越来越小（保守逻辑，尽量限制回撤或者锁定利润），通过after_fill 参数可以重新设置止损价。
5、custom_roi，自定义止盈，每次循环处理未平仓的交易时会调用，
6、check_entry_timeout、check_exit_timeout，自定义超时取消订单逻辑
7、confirm_trade_entry、confirm_trade_exit，下进/出场订单前再次确认
8、adjust_trade_position，调整仓位，会在交易时多种场景都会调用，注意接口的实现性能，每次循环都会调用，注意实现逻辑，以避免预期外的重复操作。
9、adjust_order_price和adjust_entry_price、adjust_exit_price，调整未完成订单价格，前者和后两者不能兼容
10、leverage，杠杆
11、order_filled，订单完成时调用（包括各种订单，比如买入卖出，止损、价格调整）
12、plot_annotations，绘图辅助函数，当freqUI调服务器接口时调用，可以在图表上标注某个区域或者某条线段


## 2026/01/04
定制策略注意事项：
1、可以通过--template minimal/advanced参数生成简略或者进阶的策略模板
2、处理dataframe尽量使用向量化操作，而非循环处理每行数据
3、freqtrade只能在一根完整的蜡烛图上计算。（不允许在未完整的蜡烛图上计算指标和信号，意味着信号频率跟蜡烛图的时间周期有关）
4、startup_candle_count参数指定策略稳定运行所需要的历史蜡烛数据
5、如果允许做空，要在策略中显示设置can_short = True
6、informative_pairs用于设置参照对（估计在相关性套利策略中有用到）
7、可以通过ticker接口获取实时数据
8、前视偏差：回测逻辑中，dataframe是整个数据都会被处理，因此不要用整个timeframe数据计算某个指标，也不要用负数的偏移量来计算指标
9、测试策略时，多使用lookahead-analysis和recursive-analysis等工具检测策略是否存在问题


## 2026/01/03
配置顺序：
1、命令行参数
2、环境变量
3、配置文件
4、策略实现时设置的默认参数



## 2026/01/02

机器人的循环工作流bot_start()，每隔internals.process_throttle_secs秒：
1、准备数据
    1.1、本地订单记录
    1.2、下载k线数据
    1.3、本地订单记录和交易所订单状态对账
    1.4、回调bot_loop_start()，用于执行交易前的工作（可选）
    1.5、根据数据计算技术指标populate_indicators()、populate_entry_trend()、populate_exit_trend()
2、和交易所对账订单和交易数据
    2.1、order_filled()对账已完成订单
    2.2、对账超时订单check_entry_timeout()、check_exit_timeout()
    2.3、调整订单价格adjust_order_price()
3、调整未平仓交易
    3.1、根据策略，检测某个交易是否产生了平仓信号
    3.2、根据策略，确定平仓价格exit_pricing
    3.3、下平仓订单前，confirm_trade_exit()确认退出
4、调整已开仓位
    4.1、通过adjust_trade_position()下一个额外的订单，调整仓位
3、新开仓
    3.1、检查是否达到开仓上限max_open_trades
    3.2、根据策略，检测开仓价格entry_pricing or custom_entry_price()
    3.3、根据策略，确定杠杆leverage()以及下注额custom_stake_amount()
    3.4、开仓前再次confirm_trade_entry()确认


回测的循环工作流：
1、加载历史数据
2、populate_indicators()计算技术指标
3、populate_entry_trend()计算入场信号和populate_exit_trend()计算出场信号
4、loop，对于历史数据中的每个蜡烛图，都执行以下：
    4.1、调bot_loop_start()执行预备工作
    4.2、check_entry_timeout()、check_exit_timeout()检查订单超时
    4.3、adjust_order_price()调整订单的价格
    4.4、通过enter_long/enter_short列检查是否有入场信号
    4.5、confirm_trade_entry()确认进场和confirm_trade_exit()出场交易
    4.6、调用custom_entry_price()确定入场订单的价格
    4.7、leverage()确定杠杆，custom_stake_amount()确定仓位
    4.8、adjust_trade_position()调整已开仓的仓位
    4.9、order_filled()处理已完成的入场订单
    4.10、通过custom_stoploss()和custom_exit()确定出场信号
    4.11、custom_exit_price()确定出场价格
    4.12、order_filled()处理已完成的出场订单


正式工作流和回测工作流的差异：
正式工作流先处理未完成订单，然后是处理未平仓交易，最后再处理新开仓的操作


## 2026/01/01

freqtrade中PairLocks是什么，有什么作用？

先阅读freqtrade的官方文档，了解哪些特性，然后再深入掌握细节


## 2025/12/30
看病、换眼镜

1、跟AI讨论量化策略
    1.1、量化策略的划分维度
    1.2、影响量化策略效果的因素
    1.x、获取盈利的量化策略的方式（论坛？论文？博主？）


2、让AI推荐几种获取具有可信度的加密货币/区块链实时资讯的方式（不限语言）
    2.1、youtube视频博主 （Coin Bureau 、腦哥 Chill 塊鏈 ）
    2.2、资讯站点

之前提到可以通过分析链上数据来构建量化策略，那么分析链上数据具体是怎么操作的，成本如何？


## 2025/12/29


我已经为你设计了一份专门用于**实时解析复杂代码片段**的提示词。你可以将此提示词保存为模板，在VSCode中使用Claude Code时，选中代码并附加此提示词，即可获得清晰的逐行解析。

## **AI提示词：复杂代码片段实时解析助手**

**核心指令**：
当我向你提供一段Freqtrade项目的源代码片段时，请充当我的**高级代码导师和系统分析师**，按照以下结构化框架进行解析，帮助我从微观到宏观理解这段代码。

---

### **第一步：代码片段上下文定位**
1.  **文件路径识别**：基于我提供的文件路径或上下文，明确这段代码属于哪个模块（如：策略引擎、交易所适配器、回测框架等）。
2.  **功能定位**：说明这段代码在所属模块中承担的具体职责（例如：“这是订单执行流程中的状态验证部分”）。
3.  **架构层级**：指出它在整体架构中的位置（用户交互层/核心引擎/数据层/适配器层）。

### **第二步：逐层解析与注释**
请按以下层次对代码进行分解：

**A. 表层逻辑流（做什么）**
*   用自然语言简述这段代码**从头到尾完成了什么任务**。
*   识别关键的**控制流节点**（循环、条件分支、异常处理）并说明其目的。
*   指出**关键的函数/方法调用**及其作用。

**B. 核心设计意图（为什么这样设计）**
*   **设计模式识别**：分析代码中是否运用了典型的设计模式（如工厂、策略、观察者、模板方法等），并解释其在此处的优势。
*   **接口与抽象**：如果涉及接口、抽象类或继承关系，说明这种设计如何支持扩展或解耦。
*   **状态与数据流**：追踪核心数据（如订单对象、市场数据）在此片段中如何被转换和传递。

**C. 关键实现细节（如何实现）**
*   **复杂算法/逻辑拆解**：对于难以理解的算法（如指标计算、仓位调整算法），用更简单的步骤或伪代码重新表述。
*   **并发/异步处理**：如果涉及多线程、异步IO或协程，解释其并发模型和同步机制。
*   **错误处理与边界情况**：分析代码如何处理异常、超时、数据不完整等边缘情况。

**D. 与系统的连接点**
*   **上游依赖**：指出这段代码依赖的外部输入（如配置文件、数据库查询、API响应）来自哪里。
*   **下游影响**：说明这段代码的执行结果如何影响后续流程（如触发回调、更新状态、写入数据库）。

### **第三步：可视化辅助（如适用）**
*   **绘制迷你流程图**：如果逻辑分支复杂，用文字描述一个简明的流程图。
*   **状态转换图**：如果涉及对象状态变化（如订单状态机），描述状态的迁移条件。
*   **数据转换示意**：用“输入 -> 处理 -> 输出”的形式说明关键数据的演变过程。

### **第四步：学习要点与关联**
*   **核心概念**：提炼这段代码涉及的关键编程或交易概念（如“这是市价单与限价单的执行路径分叉点”）。
*   **典型用法**：说明在自定义策略或扩展功能时，会如何与这段代码交互。
*   **常见陷阱**：提示在此处可能出现的错误使用方式或注意事项。

### **第五步：自我验证问题**
基于这段代码，提出1-2个能帮我检验理解深度的问题，例如：
*   “如果我想修改X行为，应该调整这段代码的哪个部分？”
*   “当Y条件不满足时，代码执行路径会如何变化？”

---

### **使用格式要求**
我将以以下格式提供代码片段，请你按上述框架组织回复：

```
【代码片段来源】
文件路径：freqtrade/xxx/yyy.py
类/函数名：ClassName.method_name

【代码片段】
（这里粘贴具体的代码）

【我的疑问】（可选）
我特别不理解的部分是...
```

请你在回复时，**使用清晰的标题和列表**，避免大段密集文字。对于特别关键的代码行，可以在解析中直接引用（使用行号或简短的代码引用）。

---

### **示例场景（供AI理解预期）**

假设我提供以下代码片段：

```
【代码片段来源】
文件路径：freqtrade/strategy/interface.py
类/函数名：IStrategy.populate_entry_trend

【代码片段】
def populate_entry_trend(self, dataframe: DataFrame, metadata: dict) -> DataFrame:
    dataframe.loc[
        (
            (dataframe['rsi'] < 30) &
            (dataframe['volume'] > dataframe['volume'].rolling(20).mean())
        ),
        'enter_long'] = 1
    return dataframe
```

你应当这样解析：

**第一步：上下文定位**
- 此代码位于策略接口层，是每个交易策略必须实现的核心方法之一。
- 功能：根据技术指标和条件，在DataFrame中标记入场信号。

**第二步：逐层解析**
- **表层逻辑**：在RSI低于30且成交量超过20日均线时，标记`enter_long`为1。
- **设计意图**：使用向量化操作（`dataframe.loc`）提高回测效率；返回修改后的DataFrame是模板方法模式的一部分。
- **实现细节**：条件组合使用按位与`&`；使用`.rolling().mean()`计算移动平均。
- **连接点**：此方法由回测/实盘引擎在每根K线调用，其结果会被后续的订单创建逻辑读取。

**第三步：可视化辅助**
```
条件检查流程：
[计算RSI] -> [检查是否<30] --是--> [检查成交量>20日均线] --是--> [标记入场信号]
                                      |
                                     否
                                      V
                               [不标记信号]
```

**第四步：学习要点**
- 关键概念：向量化条件判断、技术指标应用。
- 典型用法：用户自定义策略时在此处编写自己的入场逻辑。
- 常见陷阱：避免使用未来数据（如`dataframe['close'].shift(-1)`）。

**第五步：自我验证问题**
- 如果我想增加一个“价格高于50日均线”的条件，应如何修改这段代码？
- 为什么使用`&`而不是`and`？

---

请根据我提供的具体代码片段，按照以上框架进行解析。现在，我将开始提供第一个需要解析的代码片段。



请你扮演一位兼具系统架构师和资深编程导师双重角色的专家，擅长将复杂系统的源代码分解为可消化、可渐进掌握的学习单元。基于Freqtrade项目的GitHub仓库信息，为我设计一份**从入门到精通的源码研习计划**。

**核心目标是**：引导我通过“**自顶向下、由主及次、从静到动**”的路径，逐步构建起对Freqtrade完整、立体的代码心智模型。最终，我不应仅知道代码在哪，更要理解其为何这样组织、如何协作运行，并具备核心模块的二次开发能力。

**请按以下五阶段路线图，提供具体、可操作的学习指南：**

---

### **阶段零：学习环境与工具准备（半天）**
1.  **源码探索环境搭建**：推荐最有效的本地代码浏览与调试环境（如VSCode + Python插件 + Docker）。如何利用项目自带的 `devcontainer` 配置快速进入开发状态？
2.  **建立静态分析视图**：指导我如何利用 `tree` 命令或IDE，生成并理解项目的**核心目录布局**。特别关注 `freqtrade/` 目录下的子模块划分，并与之前了解的架构图建立关联。
3.  **动态跟踪入口**：找到项目真正的入口点。是 `freqtrade/__main__.py` 还是通过 `pyproject.toml` 中定义的入口点？请指出解析命令行子命令（如 `trade`, `backtesting`）的代码位置。

**本阶段产出**：一张清晰的**核心源码目录地图**，并标注出后续每个阶段将重点关注的子目录。

### **阶段一：追踪主线 - 理解“交易”的生命周期（2-3天）**
**目标**：以 `freqtrade trade` 命令为线索，理解一个策略从启动到执行一次完整交易决策的代码流程。
1.  **启动与初始化流程**：
    *   从命令行到 `main()`：参数如何被解析并分发到 `trade` 子命令的处理函数？
    *   **配置系统的加载链**：从 `configuration.py` 入手，分析默认配置、用户配置、命令行参数是如何层层合并，最终形成一个全局配置对象的。这个对象在整个系统中如何传递？
    *   **策略的动态加载机制**：在 `strategy/` 目录下，`strategy.py` 中的 `Strategy` 基类是如何定义的？`IStrategy` 接口包含了哪些必须实现的方法？`StrategyResolver` 或类似类如何从 `user_data/strategies/` 目录中发现、加载并实例化一个用户策略？
2.  **核心循环与事件流**：
    *   定位交易主循环。它很可能在 `freqtrade/bot.py` 的 `Bot` 类或 `freqtrade/worker.py` 中。用文字或流程图描述一次循环迭代（如处理一个新区块或新K线）的步骤：
        1.  获取最新市场数据（`exchange.py`）。
        2.  调用策略的 `populate_indicators` 和 `populate_entry_trend` / `populate_exit_trend`。
        3.  根据信号，通过 `trade.py` 或 `order/` 目录下的逻辑处理订单。
        4.  更新仓位状态，并持久化到数据库（`storage/`）。
    *   **关键问题**：在循环中，“干运行”模式与“实盘”模式的核心代码分支在哪？是如何实现的？

**本阶段核心任务**：绘制一幅 **“交易指令流”时序图**，从用户输入命令开始，到策略产生一个交易信号为止，标注出经过的主要类、方法及关键数据转换。

### **阶段二：解剖核心模块 - 策略、数据与交易所（3-4天）**
**目标**：深入三个最核心的模块，理解其内部设计、接口契约和扩展点。
1.  **策略引擎深度解析**：
    *   分析 `strategy/interface.py` 中的 `IStrategy` 接口。每个方法的调用时机、输入参数和期望返回值是什么？
    *   **指标计算的优化**：在 `strategy/strategy.py` 中，`populate_indicators` 方法里如何高效计算并缓存技术指标？如何避免回测时的“未来数据”泄露？
    *   **策略辅助工具**：分析 `freqtrade/strategy/strategy_helper.py` 提供了哪些通用功能（如止损计算、仓位大小计算）。
2.  **数据流抽象层**：
    *   **数据获取**：分析 `data/dataprovider.py`。它如何为策略提供统一的数据访问接口，屏蔽实时数据和历史数据的差异？
    *   **数据结构**：找到代表“蜡烛图”的核心数据结构（可能是一个Pandas DataFrame的封装）。这个数据结构在整个系统中如何传递和演变？
    *   **回测数据模拟**：深入研究 `data/bt_provider.py` 或 `backtesting/data.py`，看回测时如何模拟时间向前推进和数据供给。
3.  **交易所适配器模式**：
    *   **抽象基类**：研究 `exchange/` 目录下的 `exchange.py`。其中定义的 `Exchange` 类包含了哪些所有交易所都必须实现的方法（如 `fetch_ticker`, `create_order`, `get_balances`）？
    *   **具体实现**：选择一个熟悉的交易所（如 `exchange/binance.py`），看它如何继承基类，实现具体的REST API或WebSocket调用。
    *   **统一性与特殊性**：分析项目如何处理不同交易所的API差异（如速率限制、错误码、订单类型）。`exchange/common.py` 中是否有共享的工具函数？

**本阶段核心任务**：为每个核心模块总结一个 **“接口契约与扩展指南”** 表格。例如对于策略模块，列出必须覆盖的方法、可选覆盖的方法、以及常用的工具函数。

### **阶段三：解密高级子系统 - 回测、优化与风控（2-3天）**
**目标**：理解系统如何验证和优化策略，以及如何管理风险。
1.  **回测引擎**：
    *   跟踪 `backtesting/backtesting.py` 中的 `Backtesting` 类。它与实盘交易的主循环有何异同？
    *   **历史订单模拟**：分析 `backtesting/backtesting.py` 中订单是如何被模拟执行的。重点关注 `_process_exit_signals` 和 `_enter_trade` 等方法。
    *   **性能分析**：回测结果中的各种指标（夏普比率、最大回撤、胜率）是在哪里计算的？（查看 `backtesting/backtesting.py` 或独立的 `analytics` 模块）。
2.  **超参数优化**：
    *   概览 `optimize/hyperopt.py` 的架构。它是如何与策略参数空间定义、损失函数结合，并调用外部优化库（如 `scikit-optimize`）进行搜索的？
3.  **风险管理与仓位控制**：
    *   定位风险管理模块（可能在 `money/` 或 `risk/` 目录下）。分析 `calculate_position_size` 等函数如何根据账户余额、风险百分比和止损距离来计算下单量。
    *   **动态止损**：跟踪 `trailing_stop_loss` 功能的实现，理解其如何根据市场价格动态更新止损位。

**本阶段核心任务**：选择一个简单策略，**人工模拟一次回测引擎的思维过程**，说明从加载数据、遍历时间、调用策略、模拟成交到计算结果的每一步，在代码中对应哪些函数。

### **阶段四：洞察系统级设计、模式与质量保障（1-2天）**
**目标**：从全局视角审视项目的设计模式、代码质量和运维支持。
1.  **设计模式识别**：
    *   **工厂模式**：策略和交易所的加载器是否是工厂模式的体现？
    *   **模板方法模式**：策略基类是否为子类定义了一个算法框架（模板）？
    *   **观察者/发布-订阅模式**：系统中是否有事件总线或消息机制来处理订单完成、日志记录等？
    *   **状态模式**：订单的状态（PENDING, OPEN, CLOSED, CANCELLED）是如何管理和迁移的？
2.  **代码质量与可维护性**：
    *   查看 `tests/` 目录结构。单元测试、集成测试、端到端测试是如何组织的？运行 `pytest` 命令，观察测试覆盖了哪些关键路径。
    *   查看 `.pre-commit-config.yaml`，了解项目使用了哪些代码质量工具（如 `black`, `isort`, `ruff`, `mypy`）。这对项目长期健康度有何意义？
3.  **可观测性与运维**：
    *   分析日志系统是如何初始化和使用的（查找 `loggers` 相关配置）。不同模块的日志如何分级和过滤？
    *   **持久化**：数据库模型定义在哪里（可能是 `storage/models.py`）？SQLite数据库是如何被封装和操作的？

**本阶段核心任务**：提交一个简短的 **“架构亮点与借鉴报告”** ，总结你在这个项目中发现的三个最值得借鉴的软件设计或工程实践，并说明原因。

### **阶段五：实践与升华 - 动手与贡献（持续）**
**目标**：通过实践巩固知识，并为项目贡献力量。
1.  **深度调试**：在关键函数（如策略的信号生成、订单创建）设置断点，使用真实或模拟数据运行，观察变量状态，彻底理解数据流。
2.  **微型二次开发**：
    *   **任务示例1**：添加一个简单的自定义技术指标，并在策略中使用它。
    *   **任务示例2**：为机器人添加一个新的状态通知渠道（如写入本地文件）。
    *   **任务示例3**：阅读一个 `good first issue`，尝试理解并修复它。
3.  **逆向工程与重构练习**：尝试为一个你理解透彻的模块（如一个简单的订单处理流程）绘制详细的UML类图或序列图。

---

**最终指南要求**：
请输出一份完整的、可直接遵循的**学习手册**。对于每个阶段：
*   **明确输入与输出**：告诉我需要预先了解什么，以及完成该阶段后我将获得什么。
*   **提供具体路径**：给出需要阅读的**核心源文件路径**、**关键类名**和**函数名**。
*   **设计验证性问题**：在每个阶段末尾，提出2-3个关键问题，用于自我检验理解程度（例如：“配置对象的优先级顺序是如何在代码中实现的？”）。
*   **保持引导性**：像一个随时在场的导师，不仅告诉我“看哪里”，还要提示我“注意什么”和“思考为什么”。

现在，请开始你的指导，首先为我勾勒出这张源码探险的总体地图。


## 2025/12/27
继续学习freqtrade的代码

我已经为你准备好了一份精心设计的提示词，用于深入探究Freqtrade的系统设计。这份提示词旨在引导AI生成一份超越基础使用的、能够洞察项目架构思想与设计精髓的文档。

### **AI提示词：深入探究Freqtrade项目设计**

请你扮演一位资深软件架构师和技术布道师，专注于分析复杂开源项目的设计哲学与实现架构。你的任务是，基于我提供的GitHub项目内容，为我生成一份名为 **《Freqtrade 项目架构深度解析》** 的详细设计文档。

**核心目标是**：不仅阐明项目“是什么”和“怎么用”，更要深刻揭示其 **“为何这样设计”以及“设计的核心亮点”** ，帮助我从开发者视角掌握其系统架构、模块划分、关键设计决策和可扩展性设计。

**请严格遵循以下结构化框架来组织和生成内容：**

---

#### **第一部分：项目设计哲学与顶层架构**
1.  **设计目标与约束**：从项目描述中提炼其核心设计目标（如多交易所支持、安全隔离、用户友好性等）及面临的技术约束（如金融市场数据的实时性、系统稳定性要求）。
2.  **核心设计原则**：分析项目在代码组织、配置管理、扩展性方面遵循的原则。例如：
    *   **用户代码与核心代码分离**：如何通过 `user_data/` 目录实现？
    *   **“干运行”优先**：这一安全理念如何贯穿于整个系统设计？
    *   **配置驱动**：如何通过配置文件实现绝大部分行为控制，而非硬编码？
3.  **系统高层次架构图描述**：请用文字描绘一个清晰的、分层的架构图。至少应包括：
    *   **用户交互层** (Telegram Bot, WebUI, CLI)
    *   **核心策略执行引擎**
    *   **数据抽象层** (交易所适配器)
    *   **持久化层** (SQLite数据库)
    *   **外部服务依赖** (交易所API, 可能的机器学习服务)

#### **第二部分：核心模块设计与交互剖析**
**这是文档的重点。** 请将README中提到的功能点和目录结构转化为模块化分析。
1.  **策略引擎**：
    *   **接口与生命周期**：分析一个典型策略文件（如通过`new-strategy`创建）中定义的方法（如`populate_indicators`, `populate_entry_trend`），解释它们如何被核心引擎在特定阶段（如每个K线周期）调用。
    *   **热重载机制**：项目如何支持在不重启机器人的情况下更新策略？
2.  **回测框架设计**：
    *   **数据流模拟**：解释回测模块如何模拟实时交易环境，包括数据馈送、订单执行、手续费计算。
    *   **避免“未来函数”的设计**：分析 `lookahead-analysis` 等工具存在的意义，体现了何种严谨的设计考量？
3.  **配置与状态管理**：
    *   **配置的继承与覆盖逻辑**：分析项目可能如何处理默认配置、用户配置和命令行参数之间的优先级。
    *   **状态持久化**：结合“Persistence is achieved through sqlite”，说明交易状态、机器人运行状态如何被保存和恢复，这如何保证了系统的鲁棒性？
4.  **交易所适配器模式**：
    *   **抽象设计**：项目如何通过统一的接口来支持数十个不同的交易所？`list-exchanges`、`list-markets` 等命令反映了怎样的抽象层次？
5.  **扩展点与插件系统**：
    *   **指标库扩展**：分析如何方便地添加自定义技术指标。
    *   **配对列表动态筛选**：`test-pairlist` 命令表明配对列表是一个可测试、可组合的模块。请分析其设计。

#### **第三部分：关键设计决策与权衡分析**
分析项目中一些值得深思的设计选择，并阐述其利弊：
1.  **技术栈选择**：为何选择Python作为主力语言？这对于策略开发的便利性、性能以及部署带来了什么影响？
2.  **依赖管理**：项目通过 `requirements-*.txt` 将依赖按功能拆分（如`freqai`, `plot`, `hyperopt`）。这种设计有何好处？它如何影响用户的安装和部署？

#### **第四部分：项目质量与工程实践洞察**
1.  **代码质量保障**：从仓库中存在的 `.pre-commit-config.yaml`、`.coveragerc` 等文件，分析项目采用了哪些工程实践来保障代码质量（如代码风格检查、单元测试覆盖）。

#### **第五部分：给二次开发者的指南**
1.  **核心源码阅读路线**：建议一个阅读核心源码的顺序。例如：从 `freqtrade/main.py` 入口开始，跟随一个“启动交易”的命令流，逐步深入策略加载、配置解析、交易所连接等模块。
2.  **如何进行有效的功能扩展**：如果我想添加一个新的通知渠道（如钉钉）或支持一个新的交易所，我应该从哪里入手？需要实现哪些接口或修改哪些核心代码？
3.  **性能关键路径与优化点**：根据项目特点，指出在策略计算、数据处理等方面的潜在性能瓶颈，以及设计上预留了哪些优化空间。

**最终输出要求**：
*   文档应结构严谨、逻辑清晰，使用专业但不过度晦涩的技术语言。
*   **突出核心重点**：对第二部分（核心模块设计）和第三部分（关键决策）进行详细阐述，其他部分可相对精炼。
*   适当使用**加粗**来强调关键概念和设计亮点。
*   在分析时，必须**紧密结合README中提供的功能描述、目录结构和命令列表**进行推论和阐述，确保分析有据可依。

---

你可以将以上完整的提示词直接发送给你选择的AI助手。这份提示词将引导AI不仅罗列信息，更能进行深入的架构分析和设计洞察，从而帮助你真正理解Freqtrade这个优秀项目的内在设计逻辑。

如果你在获得设计解析后，希望对某个特定模块（如FreqAI机器学习集成、或订单执行引擎）进行更专注的“代码级”分析，我们可以再次协作，设计更具深度的提示词。

## 2025/12/26

了解现货交易的价格的涨跌受哪些因素影响？（合约价格涨跌基于现货价格涨跌，因此搞清楚了现货的价格涨跌原因，才能赌对合约中的价格涨跌）

┌─────────────────────────────────────────────────────────┐
│           BTC vs 7亿市值山寨币 影响因素对比               │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  因素类型          BTC影响度    山寨币影响度    差异原因  │
│  ──────────       ──────────   ────────────   ──────── │
│                                                         │
│  【宏观因素】                                            │
│  美联储政策          ★★★★★        ★★          机构持仓  │
│  美元指数            ★★★★         ★★          避险属性  │
│  全球经济            ★★★★         ★★          资产配置  │
│                                                         │
│  【行业因素】                                            │
│  监管政策            ★★★★         ★★★★        都受影响  │
│  ETF/机构入场        ★★★★★        ★            标的选择  │
│  交易所事件          ★★★          ★★★★        流动性   │
│                                                         │
│  【基本面】                                              │
│  减半周期            ★★★★★        -            BTC特有  │
│  代币解锁            -             ★★★★★      山寨特有  │
│  技术升级            ★★            ★★★★        发展阶段  │
│  团队风险            ★             ★★★★★      去中心化  │
│  使用数据            ★★            ★★★★        估值逻辑  │
│                                                         │
│  【交易因素】                                            │
│  庄家操控            ★             ★★★★★      市值差异  │
│  流动性              ★★★★★        ★★          深度差异  │
│  单一大户影响        ★             ★★★★★      筹码集中  │
│  市场情绪            ★★★          ★★★★★      投机属性  │
│                                                         │
│  ★ = 影响程度（越多影响越大）                            │
│                                                         │
└─────────────────────────────────────────────────────────┘

了解下庄家是如何配合现货市场和合约市场，收割散户的

了解下美联储加息/降息对经济的影响分别是什么


了解下最新的量化+AI+加密货币论文

## 2025/12/25

币圈中的角色：庄家、巨鲸、聪明钱、散户
庄家、巨鲸和聪明钱应该有高相关性


山寨币与BTC的关系：

正常市场：
- BTC涨 → 山寨币涨更多
- BTC跌 → 山寨币跌更多

牛市中后期：
- 资金从BTC流向山寨币
- "山寨季"（Altcoin Season）出现
- 山寨币大幅跑赢BTC

熊市：
- 资金从山寨币流回BTC
- 山寨币跌幅远超BTC
- 很多山寨币归零

判断指标：
- BTC市占率（BTC Dominance）
- 高于60%：资金集中在BTC，山寨币弱势
- 低于40%：山寨季，山寨币强势

## 2025/12/24
对于庄家盘，散户要做什么，后续庄家就反着做，可以根据这个特征跟庄下注

对于庄家盘，不仅要分析技术指标，更要分析散户行为的指标，以预判庄家的操作

对于庄家盘，盈利点如下：
1、现货低买后在出货价卖出
2、合约中同步做多
3、在出货阶段合约做空
（要预判准庄家的行为）

要预判的因素：
1、散户的突破点位
2、庄家的震荡点位

高频/短线交易

盈利公式为： **期望收益率 = 胜率 * 止盈 - （1-胜率） * 止损**
即，**胜率 = （期望收益率+止损）/（止盈+止损）**
当期望收益率>0，则 胜率 > 止损/(止盈+止损)
比如下注某个合约，做多，上涨5%止盈，下跌2.5%止跌。,则胜率需要为 2.5%/(5%+2.5%) = 1/3


## 2025/12/23
对于永续合约，有哪些盈利策略，以及有哪些风险点需要注意？
了解庄家拉升和出货的逻辑


个人永续合约盈利经验：分析k线图，挂个预判单，具体为:
1、限价买/卖单，并且设置止损止盈点，
2、止损点比止盈点离进场点更近，即预判失败及时离场，成本为手续费+（进场-止损价差）
3、如果预判成功率>60%，应该可以盈利，且不用盯盘
4、预判成功率的关键：利用区间震荡，见好就收，不要有任何幻想  
5、该方式适合量化
6、杠杆越大，操作要求越高，操作时间越短（否则震荡会可能会强平）

### 庄家为什么会赢
1、专业玩家，掌握市场绝大多数信息（相当赌骰子，庄家能看到所有人的下注，并且可以低成本改骰子点数）
2、散户的止盈止损大多中庸，会被庄家精准打击，然后被收割（买对了，但是没活到终点）
3、剩下激进的散户，操作错误的也会被收割（上涨卖空或者下跌买多）。没被收割的在高风险投资中无法找到精准的止盈点，即无法完全兑现高风险带来的高收益。
4、庄家 成本：操控市场价格的成本；盈利：大多数散户的钱。因此庄家需要**最小化操纵市场价格的成本**以获取最大收益
5、散户 大多被收割，或爆仓或割肉离场；少数盈利也是高风险下的中等收益。最终所有散户的收益期望均为0。


### 量化交易者的盈利点
1、实时监控市场，类似盯盘
2、精准下单，相比人工下单有更少的滑点成本
3、自动化判断市场趋势，赚取市场波动（庄家操盘，散户进场）中低买高卖的收益。
4、也就是说，量化交易者最有可能成为散户中，极少数能够盈利的人（所有操作都是策略最优解）






## 2025/12/22


### 庄家操盘出货时机如何捕捉？
详见 加密货币/庄家出货信号.md

简洁总结：

```
第一步：持续监控关键信号

重点观察：
1. 资金费率变化（这是最重要的！）
   └─ 当资金费率从-1.5%转向正值时，进入警戒状态
   └─ 当资金费率超过+0.5%时，可以考虑开始建仓做空

2. 价格行为
   └─ 如果再次冲击4.52失败，是做空信号
   └─ 如果出现看跌吞没或黄昏星，是强信号

3. 成交量
   └─ 如果再次放出天量但价格不涨，是强烈信号

第二步：等待入场时机

最佳入场条件（至少满足2-3个）：
□ 资金费率转正且>+0.3%
□ 价格第二次或第三次冲高失败
□ 出现明确的反转K线形态
□ 放量滞涨
□ 跌破4.0支撑位

第三步：执行交易

入场价位：根据信号出现时的价格
仓位：$100全部（既然你说可以全亏）
杠杆：建议5倍（平衡风险和收益）
止损：设在入场价上方10-15%的位置

举例：
- 如果在4.3入场做空
- 止损设在4.8（约12%）
- 目标看3.5-3.8（约12-20%收益）
- 风险收益比约1:1到1:1.5
```



## 2025/12/21


#### 小币种庄家操盘问题
问claude，在永续合约中，大户可以通过操盘收割吗？具体怎么操作？
作为普通投资者，为避免这些风险，有哪些建议？
如果大户能通过这些信息差操控市场，散户可以通过哪些方式减少信息差
那么当K线图出现一根插针的时候，意味着哪些信息？插针的底部的价格对我们有什么启示？
详见 加密货币/币圈大户的操盘问题-claude回答.md

真实的币圈中，是否有反技术策略，专门收割技术派的钱。（启示：合约市场加杠杆后，技术派的指标会被大户利用制造虚假信号；所以技术派最好不要加杠杆）



freqtrade学习

了解币圈中的理财产品：流动性挖矿/DeFi
1、 x * y = z， 自动做市商
2、付出：参与者给提供存入两种代币，为自动做市商提供流动性
3、回报：自动做市商可获得交易手续费、以及流动性挖矿奖励（治理代币如uni、sushi）
## 2025/12/20
手动实战永续合约，了解合约的玩法

## 2025/12/19

了解下通过claude快速学习一个项目的技巧（找视频和资料）
开始学习freqtrade这个工具（跟着claude学习这个项目）

freqtrade问题记录：
如何通过hyperopt和IntParameter进行参数优化？

## 2025/12/18

**加密货币的很多波动都出现在23:00附近**

**加密货币是如何发行的？在meme币的案例中，似乎发行一种加密货币非常方便，好像人人都可以无成本地发行一款加密货币。事实是这样吗？**
两种情况：
1、代表整条区块链的币。
    1.1、全新独立的区块链的币，发行需要开发整条区块链，资金、人力和时间成本都很高。BTC、ETH、SOL
    1.2、fork其他区块链源码，并调整参数，发行的币：人力、时间成本低，但资金成本依旧很高。DOGE币
2、在区块链上扩展的币。只需写智能合约，成本很低。Meme币

```
【两种加密资产的本质区别】

┌─────────────────────────────────────────────────────────────────┐
│                                                                 │
│         Coin（币）                    Token（代币）              │
│         独立区块链                    依附现有区块链              │
│                                                                 │
│    ┌─────────────────┐          ┌─────────────────┐            │
│    │                 │          │   Ethereum      │            │
│    │    Bitcoin      │          │   ┌─────────┐   │            │
│    │    区块链        │          │   │ USDT    │   │            │
│    │                 │          │   │ UNI     │   │            │
│    │    BTC          │          │   │ LINK    │   │            │
│    │                 │          │   │ SHIB    │   │            │
│    └─────────────────┘          │   │ PEPE    │   │            │
│                                 │   └─────────┘   │            │
│    ┌─────────────────┐          │                 │            │
│    │                 │          └─────────────────┘            │
│    │    Ethereum     │                                         │
│    │    区块链       │          ┌─────────────────┐            │
│    │                 │          │   Solana        │            │
│    │    ETH         │          │   ┌─────────┐   │            │
│    │                 │          │   │ BONK    │   │            │
│    └─────────────────┘          │   │ WIF     │   │            │
│                                 │   │ JUP     │   │            │
│    ┌─────────────────┐          │   └─────────┘   │            │
│    │                 │          │                 │            │
│    │    Solana       │          └─────────────────┘            │
│    │    区块链       │                                         │
│    │                 │                                         │
│    │    SOL         │                                         │
│    │                 │                                         │
│    └─────────────────┘                                         │
│                                                                 │
│    难度：极高                     难度：极低                     │
│    成本：数百万美元               成本：几美元到几百美元          │
│    时间：数年                     时间：几分钟到几小时            │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 1.2 详细对比

| 维度 | Coin（独立区块链） | Token（链上代币） |
|------|-------------------|------------------|
| **技术要求** | 需要开发整条区块链 | 只需写智能合约 |
| **开发成本** | $500K - $50M+ | $0 - $1,000 |
| **开发时间** | 1-5年 | 几分钟到几天 |
| **安全性** | 需要自己保障 | 依赖底层链 |
| **需要矿工/验证者** | 是 | 否 |
| **代表** | BTC, ETH, SOL | USDT, UNI, SHIB |


**智能合约是什么？**
```
┌─────────────────────────────────────────────────────────────────┐
│                    智能合约核心要点                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  1. 本质                                                        │
│     智能合约 = 部署在区块链上的自动执行程序                      │
│                                                                 │
│  2. 特点                                                        │
│     - 代码公开透明                                              │
│     - 部署后不可修改                                            │
│     - 自动执行，不可阻止                                        │
│     - 运行在所有节点上                                          │
│                                                                 │
│  3. 执行                                                        │
│     - 用户发送交易触发                                          │
│     - EVM 执行字节码                                            │
│     - 消耗 Gas 作为费用                                         │
│     - 结果写入区块链                                            │
│                                                                 │
│  4. 开发                                                        │
│     - 主要使用 Solidity 语言                                    │
│     - 编译成字节码部署                                          │
│     - 需要安全审计                                              │
│                                                                 │
│  5. 应用                                                        │
│     - 代币（ERC-20）                                            │
│     - NFT（ERC-721）                                            │
│     - DeFi（DEX、借贷、衍生品）                                 │
│     - DAO、游戏、社交等                                         │
│                                                                 │
│  6. 为什么发币容易                                              │
│     - 代币只是合约中的余额记录                                  │
│     - 标准化接口（ERC-20）                                      │
│     - 工具成熟，门槛极低                                        │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```
```
【智能合约不能做的事】

┌─────────────────────────────────────────────────────────────────┐
│                                                                 │
│  1. 不能主动执行                                                │
│     - 合约是被动的，需要外部触发                                │
│     - 不能"到时间自动执行"                                     │
│     - 需要 Keeper 网络或用户手动调用                           │
│                                                                 │
│  2. 不能访问链下数据                                            │
│     - 不能调用 API                                             │
│     - 不能获取网页内容                                         │
│     - 需要预言机（Oracle）提供外部数据                         │
│                                                                 │
│  3. 不能生成真随机数                                            │
│     - 区块链要求确定性                                         │
│     - 链上"随机"可被预测和操纵                                 │
│     - 需要 VRF（可验证随机函数）等方案                         │
│                                                                 │
│  4. 不能隐藏数据                                                │
│     - 所有状态变量都是公开的                                   │
│     - private 只是限制访问方式，不是真正隐私                   │
│     - 任何人都能读取合约存储                                   │
│                                                                 │
│  5. 不能修改已部署代码                                          │
│     - 代码一旦部署就不可变                                     │
│     - 需要代理模式实现"可升级"                                 │
│     - 但这增加了复杂性和中心化风险                             │
│                                                                 │
│  6. 计算能力有限                                                │
│     - Gas 限制了复杂度                                         │
│     - 不能做大量计算                                           │
│     - 不适合 AI、机器学习等                                    │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```


**加密货币分类的技术架构分类中，layer1、layer2、layer3和layer0是具体什么？**
Layer 2解决方案旨在从Layer 1网络分担部分交易负载，让基础层专注于安全性和去中心化，而Layer 2网络更高效地处理大量交易。这句话怎么理解？

【区块链不可能三角 (Blockchain Trilemma)】

                    去中心化
                   (Decentralization)
                        △
                       ╱ ╲
                      ╱   ╲
                     ╱     ╲
                    ╱       ╲
                   ╱    ❌    ╲
                  ╱   不可能    ╲
                 ╱   同时满足    ╲
                ╱       三者      ╲
               ╱                   ╲
              ▽─────────────────────▽
          安全性                  可扩展性
         (Security)              (Scalability)


含义：
- 去中心化：节点越多、越分散越好
- 安全性：抗攻击、不可篡改
- 可扩展性：处理大量交易的能力（TPS）

传统观点认为：三者只能取其二，不能兼得

【简洁总结】

Layer 0：区块链之间的"互联网"
         让不同链能够通信
         例：Polkadot, Cosmos

Layer 1：独立运行的基础区块链
         提供安全和最终结算
         例：Bitcoin, Ethereum, Solana

Layer 2：建立在L1上的扩展层
         处理大量交易，继承L1安全
         例：Arbitrum, Optimism, zkSync

Layer 3：建立在L2上的应用专用层
         为特定应用定制优化
         例：游戏链、社交链


## 2025/12/17

搞清楚永续合约和现货杠杆的玩法
追问问题：
加杠杆时，利息是按 (本金 * 杠杆) 的数额计算，还是 (本金 * (杠杆-1))的数额计算
合约价格为什么要锚定现货价格

搞清楚目前有哪些类型的加密货币，以及为什么会有这些类型的加密货币，不同类型的加密货币分别有什么用途
1、比特币
2、ETH、SOL
3、BNB,OKB等平台币
4、山寨币
5、meme币


感觉涉及区块链技术的项目，都会发行自己的加密货币，例如Defi代币、AI代币、meme币、预言机这些，是这样吗？为什么这些项目都会发行自己的加密货币？（答：因为这些代币在产生它们的地方都发挥着一些作用，例如作为消耗代币，治理代币等）



### 永续合约

#### 是什么
以保证金为担保，通过**杠杆**交易标的资产的**价格变动**，没有到期日，可以永久持有。
合约交易的底层逻辑其实是杠杆借贷。

#### 重点关注

永续合约的创新点：
1、无到期日（相比传统期货）
2、通过资金费使价格锚定现货

永续合约的核心价值
1、杠杆提高资金效率
2、可以双向交易
3、套期保值（所以要锚定现货价格？）

永续合约的开单要素：
1、保证金，用于覆盖杠杆带来的潜在亏损
2、全仓/逐仓，爆仓风险是否隔离
3、杠杆
4、资金费，系统自动计算，用于平衡过多或者过空，使合约价格回归现货价格

#### 常见策略类型

1、同现货
2、资金费套利：资金费率套利是指在现货和永续合约市场同时执行两笔交易，相同标的资产、相反方向、相等数量、盈亏对冲。目标是从永续合约交易中的资金费率获利
3、期现套利：永续合约价格与现货价格存在偏差时套利
4、期现对冲：现货持仓对冲。锁定当前价值，等待不确定性消除后解除对冲


### 现货杠杆

#### 是什么
现货杠杆交易（Margin Trading） 是指向交易所借入资金或资产，用于放大现货交易规模的交易方式。

#### 重点关注
1、向交易所借款实现杠杆。现货杠杆的核心成本是借款利息，这是与永续合约最大的区别之一。利率会根据市场供需浮动，牛市时USDT借贷需求大，利率会上升。
2、有保证金和强平机制
3、可以获得资产所有权（同现货交易），但是需要把借款还清
4、适合场景：短期投机、需要真是资产、中等杠杆
5、独特使用场景：“真实”做空，例如向交易所借BTC卖出，然后价格下跌后买回还给交易所，盈利=做空价差-利息


## 2025/12/16

阶段总结：
1、主流的投资方式是现货交易和合约交易
2、期权门槛较高，可以在充分了解现货和合约之后去学习
3、现货杠杆

现阶段搞明白现货和合约的各种玩法（如何加杠杆），还有现货杠杆

### 现货

#### 是什么

最原始的交易方式：物品-货币交易。用货币买入获得物品所有权，或者出售物品换取货币。
底层机制：
1、订单簿：记录所有买入和卖出的订单
2、撮合引擎：自动匹配所有可以成交的买入/卖出订单对

#### 重点关注

订单类型（**重点**）
基础订单类型：
1、市价单：以当前市场最佳价买入/卖出。特点：立即成交，消耗市场流动性。（主动成交，即时成交）
2、限价单：以用户设置的价格买入/卖出。特点：不保证成交，提供市场流动性。（被动成交，成交时间不确定）
3、止盈止损单：以用户设置的止盈/止损点卖出。特点：只有卖出单，需要先买入后，才能创建该类型订单（被动成交，成交时间不确定）

高级订单类型：
1、止损限价单：以市价单创建，当价格滑点到止损点，转成限价单
2、OCO顶单：同时创建止盈单和止损单，当其中一个订单成交触发时，另一个订单取消
3、冰山订单：只显示订单的部分信息。用于隐藏交易意图
4、FOK订单：全部成交或者全部取消，用于确保完整成交
5、IOC订单：立即成交部分，剩余取消，用于快速部分成交（感觉类似止损限价单的优化版）
6、GTC订单：一直有效直到成交或者取消。用于长期挂单
7、GTD订单：指定日期前有效。用于短期挂单

#### 常见策略类型

基础策略：
1、买入持有。最原始的交易策略
2、定投。优势：平滑买入成本，适合长期看多
3、网格交易（类似均值回归策略）：在价格区间设置多个买卖点，自动低买高卖
趋势/动量策略
4、均值回归：通过某均线价格+波动阈值确定买卖信号，低买高卖。
5、动量策略：计算收益率和收益率增速。收益率为正，且增速变大，买入；增速变小，卖出
6、双均线策略：计算短期均线价格和长期均线价格，两者价格交叉时产生买卖信息，短线上穿长线买入；短线下穿长线时卖出
套利策略
7、跨交易所套利：通过不同交易所的同一资产的价差进行套利，当价差大于交易成本时盈利
8、统计套利：原理是假设相关性高的两个资产相关系数长期是固定的。当短期相关系数偏离时，可以通过买入低估资产，卖出高估资产盈利
6、做市：同时挂买单和卖单，利用买卖价差盈利。（也为市场提供了流动性）

#### 交易成本

1、手续费
2、滑点
3、买卖价差（使用往返买卖策略时才需要考虑）

#### 产品优劣

优势：
✅ 最大亏损有限（最多亏完本金）
✅ 无强平风险
✅ 无持仓成本（无资金费率）
✅ 可以真正拥有资产
✅ 适合长期持有

劣势：
❌ 只能做多，无法直接做空
❌ 资金效率较低（无杠杆）
❌ 熊市中被动挨打
❌ 大资金进出有滑点



## 2025/12/15

币安的重要功能：
1、C2C充值/提现。（充值基本无风险、提现可能有资金冻结风险，提现要用一张专用卡，并且是地方小银行的卡）
2、金融产品：现货、合约（做多/做空，更高风险）（熟悉app上手动买入的操作，比如限价单市价单止盈止损买入卖出、杠杆等）
3、跟单交易：类似委托基金经理投资（可查看交易员的具体交易记录，重点关注交易员的盈亏、回撤数据）
4、交易机器人（策略）：自定义量化交易策略
5、活期存款：借币给交易所获取活期利率（本质是其他人会想交易所借贷，因此有需求）
6、LaunchPad：类似新币上市（低成本买入，基本能参与都赚钱）
7、双币投资：有风险的理财产品，不建议购买。盈利方式只有纯赚利息，但纯赚利息的方式只有在没有熊市/牛市没有冲破支撑位/阻力位的时候才出现。其他情况：熊市亏损，牛市少赚钱。非常鸡肋的一个产品


合约三个价格的原理和用途
1、最新价：最新成交的价格（分买单卖单），用于了解该交易所中某产品的最新成交价格
2、指数价：该产品在所有交易所中的加权平均价格，用于判断产品的趋势和是否稳定
3、标记价：指数价+通过合约价格计算的微小偏移，交易所认为的公平价格，可以避免短期的价格操控，交易所使用该价格来触发强制平仓，因此交易员需要根据该价格（而非最新价）来判断自己的交易是否会爆仓


欧易的重要功能（相比币安多出的功能）：
1、DEX：参与土狗代币（也称meme币）投资，它们通常没有技术白皮书，由匿名团队发行，特点是低门槛、高波动、强投机性，依赖社区热度而价格暴涨暴跌，高风险投机工具（即赌博）
2、盘前交易：交易未上架到交易所的产品
3、期权：门槛高，可以不涉及
欧易主要盈利功能：
1、现货交易
2、合约交易
3、理财赚钱：
    3.1、活期/定期存款（存币赚币息）
    3.2、链上赚币（存币到链上赚币息）
    3.3、闪赚（有活动），本质是金融产品方与交易所合作，投资者参与活动可以获得交易所的存款利息+产品方的产品利息（空投）



## 2025/12/14

学习freqtrader项目
了解币安和欧易两个app中的功能（搜视频+资料+上手）

## 2025/12/13

整理一份加密货币的量化交易学习计划
了解现在有哪些现成的框架或者工具可以用来量化交易加密货币

## 2025/12/12
了解加密货币有哪些玩法
1、加密货币有哪些玩法（现货、合约、DEX、期权等）
2、这些玩法的原理
3、不同交易所是否支持不同玩法（欧易、币安）
4、对于不同交易所，有什么推荐（欧易、币安）

了解量化交易加密货币的流程
1、如何调交易所接口
2、调接口成本
3、接口有哪些
4、量化交易全流程整合



## 2025/12/11
了解加密货币如何进行量化交易（加密货币市场似乎跑量化交易成本较低）
了解 2025如何注册和入金加密货币交易所（binance、OKX）(已完成注册和入金)

## 2025/12/10
了解 多股票定时多因子调仓策略 的实现逻辑
完整运行多股票定时多因子调仓策略回测

了解QMT


## 2025/12/9
第一维度：分析和评估市场状况的各种指标（市场技术指标，动量、趋势、波动、成交量）

第二维度：分析和评估各种技术指标的方法论，即如何衡量某个技术指标的可靠性
指标分析方法论入门：基于IC的指标分析
IC是指信息系数（Information Coeffient），衡量两个指标之间的相关性（两个指标一般是指技术指标（自变量）和收益率（因变量））
基于IC指标的分析，常见的分析指标有
1、IC
2、IC均值
3、IC标准差
4、IR
5、IC正比例

分位数组合分析：用于检测因子对收益率的相关性（检测因子和收益率是否线性相关）
多空组合收益分析：衡量策略的的alpha因子（市场无关收益）最核心和最直接的指标




## 2025/12/7
多股票回测功能
验证多个策略的效果

## 2025/12/6
继续学习指标
趋势类指标：EMA、MACD
动量类：RSI、Stochastic、CCI
波动率类：布林带、ATR
成交量类：OBV、VWAP

详见 量化指标工具箱.md



## 2025/12/5
1、指标理解：回测的各种指标理解
### 收益类指标详解

| 指标 | 说明 | 解读与深层含义 |
| :--- | :--- | :--- |
| **`Return [%]`** <br> 总收益率 | 策略期间的累计收益 | **最直观的“成绩单”**。计算公式为：`(最终权益 - 初始权益) / 初始权益 * 100%`。它回答了“我的本金最终赚了百分之几”这个最基本的问题。**局限性**：完全忽略了获取这个收益所经历的过程（波动、回撤），无法与其他不同时长策略比较。 |
| **`Buy & Hold Return [%]`** <br> 买入持有收益 | 基准对比，策略应跑赢此值 | **策略的“及格线”或“机会成本”**。它指的是在回测期初，简单买入并持有某个基准资产（如沪深300指数、标的股票）直到期末所能获得的收益率。如果您的策略收益（`Return [%]`）长期无法跑赢这个值，那么策略的附加价值就存疑，因为承担了更多主动风险却没有获得超额回报。这是衡量策略**存在必要性**的关键指标。 |
| **`Return (Ann.) [%]`** <br> 年化收益率 | 换算成年化的收益率 | **标准化收益，用于横向比较**。它通过一个标准化的时间单位（年）来平滑不同时长策略的收益。计算公式通常为：`(1 + 总收益率)^(1/回测年数) - 1`。它让你可以初步比较一个运行3年的策略和一个运行5年的策略，谁的**平均每年**赚钱能力更强。**注意**：不同平台对此计算可能略有差异，有时会考虑复利和交易日天数进行更精确的折算。 |
| **`CAGR [%]`** <br> 复合年增长率 | 考虑复利的年化收益 | **衡量长期财富增长的黄金标准**。CAGR 是 **Compound Annual Growth Rate** 的缩写。它与“年化收益率”在概念和目的上**高度相似**，都是将总收益折算成年均收益。 <br><br> **关键区别与重要性**：<br> 1. **计算原理**：CAGR 是一个**几何平均**概念，计算的是从初始值增长到最终值所需的**恒定年增长率**。公式为：`CAGR = (Equity Final / Equity Initial)^(1/年数) - 1`。<br> 2. **平滑波动**：它完全抹平了过程中的所有波动，只关注起点和终点。这使得它成为比较不同策略、不同投资项目长期真实增长能力的**最佳单一指标**。<br> 3. **与`Return (Ann.)[%]`的关系**：在许多回测报告中，两者计算一致。但`Return (Ann.)`有时可能基于算术平均或简化的时间折算，而**CAGR 特指基于几何平均的精确计算**。当两者同时出现且数值不同时，**应优先信任CAGR**，因为它更准确地反映了复利效应。 |
| **`Equity Final [$]`** <br> 最终权益 | 账户最终价值 | **成果的绝对数额**。这是扣除所有成本和费用后，在回测结束那一刻您账户里的真实资金总额。它是计算总收益率和CAGR的基础。对于固定初始本金的策略，此值与`Return [%]`信息等价。 |
| **`Equity Peak [$]`** <br> 峰值权益 | 账户历史最高值 | **衡量回撤的基准点**。这个数字本身意义不大，但其重要性在于它是计算**最大回撤（Max Drawdown）** 的关键输入。最大回撤衡量的是从任意一个历史峰值权益下跌到之后低谷的幅度。因此，`Equity Peak` 记录了策略在历史上“最辉煌”的时刻，而随后的下跌幅度则揭示了其脆弱性。 |

### **综合解读与建议**

1.  **核心逻辑链**：
    *   您投入 **`Equity Initial`**（初始本金，通常隐含）。
    *   策略运行中，资产曾达到 **`Equity Peak`**（峰值）。
    *   最终，您获得 **`Equity Final`**（最终权益）。
    *   由此算出 **`Return [%]`**（总收益）。
    *   为了公平比较，将其折算为 **`CAGR [%]`**（复合年化收益）。
    *   同时，您需要将 **`CAGR`** 或 **`Return`** 与 **`Buy & Hold Return [%]`** 比较，判断策略是否创造了超额价值。

2.  **行动指南**：
    *   **首要检查**：您的策略 `Return` / `CAGR` 是否显著且持续地高于 `Buy & Hold Return`？如果不是，需要重新审视策略逻辑。
    *   **横向比较**：使用 **`CAGR`** 来与其他策略或投资产品进行长期收益率比较。
    *   **切勿孤立看待**：高收益（`CAGR`）可能伴随着高风险。接下来，您必须结合**最大回撤（需要`Equity Peak`数据）**、**波动率**和**夏普比率**等风险指标，才能全面评估策略的优劣。一个 `CAGR` 为 20% 但回撤高达 40% 的策略，其投资体验可能远差于一个 `CAGR` 为 15% 但回撤仅 5% 的策略。

**下一步**：当您列出风险类指标（如最大回撤、波动率、夏普比率、索提诺比率等）时，我们就可以将这些收益指标与之结合，对策略的风险调整后收益和整体稳健性做出真正的评价了。

以下是风险类指标的详细解释，已整理为 Markdown 表格格式。

### 风险类指标详解表

| 指标 | 说明 | 解读与深层含义 |
| :--- | :--- | :--- |
| **Max. Drawdown [%]**<br>最大回撤 | 在选定周期内，从任一历史峰值（最高点）到后续最低点的最大跌幅。 | **策略的“生存性”与“抗压能力”测试**。这是衡量**极端风险**的最重要指标之一。它告诉你策略可能面临的最糟糕情况（需要承担的最大账面亏损）。<br><br>**关键点**：<br>1. **越小越好**：回撤越小，说明策略在逆境中的抗风险能力越强，资金曲线越平稳。<br>2. **心理与风控**：巨大的回撤（如超过50%）不仅可能导致强制平仓，还会严重打击投资者信心。<br>3. **计算**：`(峰值 - 谷值) / 峰值 × 100%`。 |
| **Avg. Drawdown [%]**<br>平均回撤 | 所有回撤（从峰值到谷值的下跌）的平均幅度。 | **策略“常态”下跌程度的衡量**。它反映了策略在运行期间，每次发生下跌时平均的亏损深度。<br><br>**关键点**：<br>1. 与最大回撤结合看：如果最大回撤很大但平均回撤很小，说明策略大部分时间表现平稳，但曾遭遇过一次极端打击；反之，则说明策略频繁出现中等程度的下跌。<br>2. **作用**：帮助理解策略回撤的“普遍水平”，评估其日常风险。 |
| **Max. Drawdown Duration**<br>最长回撤持续时间 | 从净值创下历史新高后开始下跌，直到**完全恢复**并创出下一个新高所经历的最长时间。 | **衡量策略“恢复能力”与投资者“忍耐极限”**。它回答了“如果我在最糟糕的时刻买入，最长需要等待多久才能解套并开始盈利”这个残酷的问题。<br><br>**关键点**：<br>1. **时间价值**：过长的回撤期（例如数年）会极大消耗投资者的耐心和机会成本。<br>2. **与最大回撤的关系**：一个深但短的回撤，可能比一个浅但长的回撤更容易被接受。<br>3. **形式**：通常以天（Days）或年（Years）为单位表示。 |
| **Volatility (Ann.) [%]**<br>年化波动率 | 策略每日（或每周）收益率的标准差，再年化处理。 | **现代金融理论中“风险”的核心定义**。它衡量了策略收益的**离散程度**，即收益的“不确定性”或“波动性”。<br><br>**关键点**：<br>1. **原理**：波动率越高，说明策略的收益越不稳定，风险越高。<br>2. **作用**：<br>   - 是计算夏普比率等风险调整后收益指标的基础。<br>   - 影响资金曲线的平滑度，高波动率策略的资金曲线通常“锯齿”明显。<br>3. **计算**：通常基于日收益率计算样本标准差，再乘以年化因子（如√252）。 |

### 核心使用建议

1.  **首要关注**：**`Max. Drawdown [%]`** 是所有风险指标中 **最直观、最重要的**。它直接关联到策略的潜在最大亏损和风控底线。优秀的策略必须在控制最大回撤的前提下追求收益。

2.  **风险构成分析**：
    *   结合 **`Max. Drawdown`** 和 **`Avg. Drawdown`**，可以判断策略风险的**集中度**（是偶发极端风险还是常态风险）。
    *   结合 **`Max. Drawdown`** 和 **`Max. Drawdown Duration`**，可以评估策略风险的**痛苦程度**（跌得有多深，以及要熬多久）。

3.  **现代风险度量**：**`Volatility (Ann.)`** 是进行**策略间横向比较**和**构建投资组合**的理论基石。但它只衡量了波动的幅度，并未区分上行和下行波动。

4.  **风险与收益的平衡**：这些风险指标必须与之前的收益指标（特别是 **`CAGR`**）结合起来看。经典的分析组合是：
    *   **收益风险比**：`CAGR / Max. Drawdown`
    *   **夏普比率**：`(年化收益率 - 无风险利率) / 年化波动率`


### 风险调整收益指标详解表

| 指标 | 说明 | 解读与深层含义 | 参考值与评价标准 |
| :--- | :--- | :--- | :--- |
| **Sharpe Ratio**<br>夏普比率 | 每承担一单位**总风险**（波动率）所获得的**超额收益**。 | **最经典的风险调整收益指标**。衡量风险溢价与总风险之比。<br>**公式**：`(年化收益率 - 无风险利率) / 年化波动率`。<br><br>**核心要点**：<br>1. **分子**：超额收益 = 策略收益 - 无风险收益（如国债利率），代表承担风险的额外补偿。<br>2. **分母**：年化波动率（总风险），同时惩罚上行和下行波动。<br>3. **局限性**：假设收益服从正态分布，且对上行波动（盈利波动）的惩罚可能不符合投资者心理。 | **参考值**：<br>- **>1**：可接受，收益超过风险。<br>- **>2**：优秀，风险调整后收益良好。<br>- **>3**：卓越，顶级策略。<br><br>**注意**：该值高度依赖市场环境。在低利率或牛市中可能普遍偏高；不同资产类别间不可直接比较（如股票策略与债券策略）。 |
| **Sortino Ratio**<br>索提诺比率 | 每承担一单位**下行风险**所获得的**超额收益**。 | **夏普比率的改进版**，只惩罚对投资者不利的波动（下行波动）。<br>**公式**：`(年化收益率 - 无风险利率) / 下行偏差`。<br><br>**核心要点**：<br>1. **下行偏差**：仅计算收益率低于某个目标（通常为无风险利率或0）的波动率。<br>2. **更符合实际心理**：投资者通常只担心亏损的波动，不担心盈利的波动。<br>3. **优势**：对于有正偏态（偶尔大涨）的策略，此指标评价更公平。 | **参考值**：<br>- **>2**：通常被认为良好。<br><br>**注意**：由于分母（下行偏差）通常小于总波动率，索提诺比率数值一般高于夏普比率。比较时应确保不同策略使用相同的目标收益率（MAR）。 |
| **Calmar Ratio**<br>卡玛比率 | **年化收益**与**最大回撤**的比值。 | **专注极端风险**。衡量策略在承受最大回撤后，能带来多少收益补偿。<br>**公式**：`年化收益率 / 最大回撤`（常用）或 `(年化收益率 - 无风险利率) / 最大回撤`。<br><br>**核心要点**：<br>1. **直观**：直接回答“为获得年化收益，需忍受多大亏损？”<br>2. **对回撤敏感**：适合不能忍受大回撤的投资者。<br>3. **局限性**：基于单一历史最大回撤，可能不稳定；对回测周期长度敏感。 | **参考值**：<br>- **>0.5**：可接受。<br>- **>1**：较好，年化收益能覆盖最大回撤。<br>- **>2**：优秀。<br><br>**注意**：此指标对回测时长敏感，短期回测可能因未经历完整周期而高估。 |
| **Alpha [%]**<br>阿尔法 | 相对基准的**超额收益**，且与市场波动（Beta）无关的部分。 | **主动管理能力的体现**。源于资本资产定价模型（CAPM）。<br>**公式**：通过回归 `策略收益 - 无风险利率 = Alpha + Beta × (市场收益 - 无风险利率) + 误差` 得到。<br><br>**核心要点**：<br>1. **真实超额收益**：剥离市场涨跌（Beta）后，策略自身能力带来的收益。<br>2. **可持续性**：正Alpha代表可能具有持续竞争优势（选股、择时等）。<br>3. **显著性**：需检验Alpha是否显著不为零（通常看t统计量或p值）。 | **参考值**：<br>- **>0**：有正向超额收益。<br>- **年化Alpha > 5%**：通常被认为很强。<br><br>**注意**：Alpha的估计依赖正确的基准选择和模型设定；高Alpha可能源于未识别的风险暴露。 |
| **Beta**<br>贝塔系数 | 策略收益相对于市场基准收益的**敏感度/弹性**。 | **衡量市场系统性风险暴露**。<br>**公式**：`Beta = Cov(策略收益, 市场收益) / Var(市场收益)`。<br><br>**核心要点**：<br>1. **解释**：<br>   - **Beta = 1**：与市场同步波动。<br>   - **Beta > 1**：比市场波动更大（进攻型）。<br>   - **Beta < 1**：比市场波动更小（防御型）。<br>   - **Beta ≈ 0**：与市场无关（市场中性）。<br>2. **用途**：分解收益来源（Beta收益 vs Alpha收益）；调整组合风险暴露。 | **参考值**：<br>- **1**：市场中性（相对基准）。<br>- **0.5-1.5**：常见范围。<br><br>**注意**：Beta可能随时间变化；负Beta表示与市场反向，但极少见。 |

---

#### 核心使用建议

##### 1. 综合评估，勿依赖单一指标
- **互补性**：
  - **夏普 vs 索提诺**：若夏普较低但索提诺较高，说明策略下行风险控制好，但上行波动大（如趋势策略）。
  - **夏普 vs 卡玛**：若夏普高但卡玛低，说明策略常有小回撤，但曾有一次巨大回撤。
  - **Alpha vs Beta**：高Alpha伴随高Beta，可能超额收益主要来自承担更高市场风险，而非真正技能。

##### 2. 理解指标的计算前提与局限性
- **数据频率**：确保年化计算一致（如使用252个交易日）。
- **无风险利率**：夏普与索提诺对此敏感，需明确取值（如3个月国债利率）。
- **统计显著性**：Alpha和Beta需结合显著性检验（p值或置信区间）判断可靠性。

##### 3. 结合策略类型选择重点指标
- **对冲/市场中性策略**：重点关注Alpha和Beta（应接近0），夏普比率。
- **趋势/宏观策略**：重点关注索提诺比率（因常具正偏态）和卡玛比率（回撤控制）。
- **高频/套利策略**：重点关注夏普比率（通常极高）和最大回撤。

##### 4. 实战决策示例
假设两个股票策略：
- **策略A**：年化收益20%，最大回撤15%，夏普1.8，索提诺2.5，卡玛1.33，Alpha=12%，Beta=1.1。
- **策略B**：年化收益25%，最大回撤30%，夏普1.2，索提诺1.8，卡玛0.83，Alpha=8%，Beta=1.5。

**分析**：
- 虽然策略B收益更高，但其风险调整后收益（夏普、索提诺、卡玛）全面低于策略A。
- 策略B的Beta更高，说明其超额收益更多来自市场暴露（牛市表现好，熊市可能更差）。
- 对于风险厌恶型投资者，策略A是更优选择（更高的单位风险收益、更小回撤）。

---

#### 进阶思考：指标陷阱与应对

1. **过拟合导致虚假高指标**：回测中过度优化参数可能使所有指标都很漂亮，但实盘失效。应对：样本外测试、敏感性分析。
2. **幸存者偏差**：使用当前存续股票回测会高估历史表现。应对：使用历史当时存在的股票池。
3. **交易成本与滑点**：未充分考虑成本会高估收益，低估风险。应对：在回测中纳入保守的成本假设。
4. **市场环境变化**：策略可能只在特定市场环境下有效。应对：进行多周期回测（牛、熊、震荡市）。

这些风险调整收益指标是评估策略“性价比”的核心工具，但必须结合对策略逻辑、市场环境和潜在偏差的深入理解，才能做出稳健的投资决策。

#### （个人思考和理解）
##### 利率分类
1、无风险利率：不需要任何投资行为就能产生的利率（对标银行利率）
2、市场总利率：不使用策略，在某个市场投资产生的利率（市场总利率 = 市场额外利率 + 无风险利率） 
3、策略总利率：在某个市场使用了策略后产生的利率（策略总利率 = 无风险利率 + 市场额外利率*beta + 策略无风险利率（alpha））

##### 策略影响因子
主流量化策略建模方式假定：每种策略都有alpha和beta两个影响因子，alpha衡量策略带来的超额收益（简单粗暴），beta则衡量策略相对市场正常利率水平的激进度（比市场更高收益/风险）。
alpha = 策略总利率 - 无风险利率 - 市场额外利率*beta
Beta = Cov(策略收益, 市场收益) / Var(市场收益)
影响因子排列组合：
1、高alpha，高beta：策略虽然有高风险（beta高意味着市场下行时承担更大风险），但是有超高收益（高beta带来的市场上行时更高收益+高alpha带来的超额收益）。策略性价比较高
2、高alpha，低beta：策略收益与市场无关，类似统计套利，策略本身带来的无风险利率。总体性价比高
3、低alpha，高beta：策略不带来额外无风险利率，靠beta放大市场的收益率来盈利。总体性价比一般
4、低alpha，低beta：策略不带来额外无风险利率，也不能放大市场收益率，相当没有策略。总体性价比低

##### 风险调整收益指标速记

夏普比率：衡量每承担一单位风险（波动率）所获得的超额收益。缺点是将上行波动也视为风险的一种，不够符合直觉。重要指数：⭐⭐⭐⭐
索提诺比率： 衡量每承担一单位下行风险所获得的超额收益。计算公式更加符合风险与收益的定义。重要指数：⭐⭐⭐⭐⭐
卡玛比率：衡量策略在承受最大回撤后，能带来多少收益补偿。对回撤比例敏感时需关注。重要指数：⭐⭐⭐
阿尔法因子：策略带来的无风险额外收益。越高越好。重要指数：⭐⭐⭐⭐⭐
贝塔因子：策略带来的撬动市场波动的强度系数。越高越激进。重要指数：⭐⭐⭐⭐⭐


### 交易统计指标详解表

| 指标 | 说明 | 解读与深层含义 | 计算与注意事项 |
| :--- | :--- | :--- | :--- |
| **`# Trades`**<br>交易次数 | 回测期间内所有买卖交易的总次数（通常按开仓+平仓算一次完整交易）。 | **策略活跃度的基本度量**。<br>1. **策略类型判断**：高频策略>1000次/年；日内策略>100次/年；趋势策略可能<50次/年。<br>2. **统计显著性**：交易次数越多，回测结果越可靠（统计意义越强）。<br>3. **成本敏感度**：交易次数越多，总手续费和滑点成本影响越大。 | **注意**：需区分“交易次数”与“交易信号数”。有些策略生成信号后可能因风控未能成交。 |
| **`Win Rate [%]`**<br>胜率 | 盈利交易笔数占总交易笔数的百分比。 | **衡量策略的“正确率”**。<br>1. **心理体验**：高胜率（>60%）带来更好的交易体验和执行力。<br>2. **与盈亏比的关系**：胜率和盈亏比通常呈反比。需结合看：<br>   - 高胜率+低盈亏比：如做市策略、套利策略<br>   - 低胜率+高盈亏比：如趋势跟踪策略<br>3. **阈值**：>50%是基础要求，但并非绝对，盈亏比高的策略30-40%胜率也能盈利。 | `胜率 = 盈利交易笔数 / 总交易笔数 × 100%`<br>**注意**：“盈利”定义为扣除手续费和滑点后的净利润>0。 |
| **`Best Trade [%]`**<br>最佳交易 | 所有交易中，单笔收益率最高的交易的收益率。 | **策略的上行潜力**。<br>1. **盈利来源分析**：最佳交易是否异常值？是否依赖单次“黑天鹅”事件？<br>2. **策略一致性**：最佳交易收益率远高于平均交易，可能预示策略不稳定。<br>3. **与最大回撤关系**：最佳交易能否覆盖最大回撤？ | **注意**：警惕最佳交易是数据错误或特殊事件（如财报、并购）导致，这些在实盘中不可复制。 |
| **`Worst Trade [%]`**<br>最差交易 | 所有交易中，单笔亏损率最大的交易的亏损率。 | **策略的下行风险**。<br>1. **风控有效性**：最差交易反映了极端情况下的单笔损失，检查止损机制是否有效。<br>2. **与胜率关系**：即使胜率高，一次巨大亏损可能摧毁多次盈利。<br>3. **心理承受**：投资者能否承受这样的单笔亏损？ | **注意**：最差交易应与市场极端事件（如闪崩、流动性枯竭）关联分析。是否因流动性不足导致无法止损？ |
| **`Avg. Trade [%]`**<br>平均交易收益 | 所有交易收益率的算术平均值。 | **策略的平均盈利能力**。<br>1. **收益质量**：平均收益应显著大于0，且最好超过交易成本（手续费+滑点）的2-3倍。<br>2. **分布形态**：若平均收益>0，但中位数收益<0，说明收益分布严重右偏（靠少数大赢家）。<br>3. **统计检验**：平均收益是否显著大于0（t检验）？ | `平均收益 = 所有交易收益率之和 / 交易次数`<br>**注意**：收益率通常使用百分比表示，但计算期望值时需用小数。 |
| **`Profit Factor`**<br>利润因子 | 总盈利金额与总亏损金额的比值。 | **衡量策略的盈利效率**。<br>1. **核心指标**：>1表示总体盈利，<1表示总体亏损。<br>2. **解读**：<br>   - 1.0-1.5：边际盈利<br>   - 1.5-2.0：良好<br>   - 2.0-3.0：优秀<br>   - >3.0：卓越<br>3. **与胜率关系**：利润因子综合了胜率和盈亏比信息。 | `利润因子 = 总盈利金额 / \|总亏损金额\|` <br>**注意**：1）总盈利、总亏损均取绝对值；2）对交易成本敏感，需扣除成本后计算。 |
| **`Expectancy [%]`**<br>期望值 | 每笔交易的平均预期收益率。 | **策略的“数学期望”**，结合了胜率和盈亏比的核心指标。<br>1. **公式推导**：`期望值 = (胜率 × 平均盈利) - (败率 × 平均亏损)`<br>2. **实战意义**：>0是盈利的必要条件，数值越大，每笔交易的预期收益越高。<br>3. **资金管理基础**：用于计算凯利准则、最优仓位等。 | **注意**：期望值通常以百分比表示，但也可转换为金额。需用足够多的交易样本计算。 |
| **`SQN`**<br>系统质量数 | System Quality Number，由Van Tharp提出，衡量策略收益与风险的比率。 | **评估策略的稳健性和统计显著性**。<br>1. **公式**：`SQN = (平均收益 / 收益标准差) × √交易次数`<br>2. **解读**：<br>   - <1.6：策略质量较差<br>   - 1.6-2.0：一般<br>   - 2.0-3.0：良好<br>   - >3.0：优秀<br>   - >4.0：卓越<br>3. **优势**：结合了盈利能力和样本量，可用于比较不同频率的策略。 | **注意**：SQN对交易次数敏感，低频策略即使质量高也可能SQN较低。建议交易次数>100时使用。 |
| **`Kelly Criterion [%]`**<br>凯利准则 | 在给定胜率和盈亏比下，理论上使长期复利增长最大化的最优仓位比例。 | **资金管理的理论最优解**。<br>1. **公式**：`f* = (p × b - q) / b`，其中p=胜率，q=败率，b=盈亏比（平均盈利/平均亏损）。<br>2. **应用**：<br>   - 建议仓位 = 凯利值 × 可用资金<br>   - 通常使用“半凯利”或“1/4凯利”以降低风险<br>3. **局限性**：<br>   - 假设收益分布已知且稳定<br>   - 忽略交易成本、资金连续性<br>   - 可能建议激进仓位 | **注意**：凯利准则对参数敏感，微小估计误差可能导致巨大仓位变化。**切勿直接使用满凯利**。 |
| **`Exposure Time [%]`**<br>持仓时间比 | 策略持有头寸的时间占总回测时间的百分比。 | **衡量策略的市场暴露程度和资金利用率**。<br>1. **策略类型**：<br>   - 高频/日内：持仓时间比低（可能<10%）<br>   - 趋势/长线：持仓时间比高（可能>80%）<br>2. **风险关联**：持仓时间越长，暴露于市场风险的时间越长，可能经历更多回撤。<br>3. **与夏普比率**：持仓时间低可能夏普比率高（单位时间收益集中）。 | **计算**：`持仓时间比 = 总持仓时间 / 总回测时间 × 100%`<br>**注意**：对于多品种、多空对冲策略，净持仓可能接近零，但总持仓时间比仍高。 |

---

#### **核心使用建议**


##### 3. 常见问题诊断表

| 问题现象 | 可能原因 | 检查指标 |
|----------|----------|----------|
| **高胜率但低利润因子** | 盈亏比过低，平均盈利远小于平均亏损 | 平均交易收益、利润因子、最差交易 |
| **利润因子高但收益低** | 交易次数太少，或持仓时间比过低 | # Trades、Exposure Time、SQN |
| **最佳交易占比过高** | 收益依赖少数交易，策略可能不稳定 | 最佳交易 vs 平均交易、收益分布 |
| **SQN<1.6但期望值>0** | 交易次数不足或收益波动太大 | # Trades、收益标准差、最大回撤 |
| **凯利值>50%** | 胜率和盈亏比估计可能过于乐观，或未考虑风险 | 胜率、盈亏比、最差交易、回测周期 |

## 2025/12/4

1、数据处理、数据可视化、数据操作（各种指标计算使用的接口函数）
2、了解python提供的并行计算方式（向量化计算）
3、正常运行第一个策略回测，策略为双均线交叉策略
4、了解回测的代码逻辑，了解策略参数优化逻辑

## 2025/12/3

量化实战学习第一阶段开始：
配置量化Python环境，了解量化的软件生态（数据平台tushare、akshare等，回测平台vnpy、backtrader、backtesting等）
验证行情数据拉取代码