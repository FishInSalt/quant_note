# 量化交易第二阶段待办清单（第2-3个月）

> **使用说明**：本文档设计用于Claude Code编程终端辅助执行
> **前置条件**：已完成第一阶段学习（Python量化基础 + 3个策略回测）
> **阶段目标**：vnpy框架掌握 + 多因子模型进阶 + 风险管理体系 + QMT模拟交易 + Go语言量化模块

---

## 阶段概览

| 周次 | 主题 | 核心产出 |
|------|------|----------|
| 第5周 | vnpy框架入门 | CTA策略开发 + 本地回测 |
| 第6周 | vnpy进阶 + 数据管理 | 多品种策略 + 时序数据库 |
| 第7周 | 多因子模型进阶 | 因子合成 + 机器学习选股 |
| 第8周 | 风险管理体系 | 完整风控模块 + 仓位管理 |
| 第9周 | QMT模拟交易 | 策略部署 + 模拟实盘 |
| 第10周 | Go语言量化模块 | 高性能组件 + 系统整合 |

---

## 第五周：vnpy框架入门

### Day 29-30：vnpy环境搭建

- [ ] **TODO-P2-1.1** 安装VeighNa Studio
  ```bash
  # 方式一：使用官方一键安装包（推荐）
  # 下载地址：https://download.vnpy.com/veighna_studio-4.2.0.exe
  # 安装路径不要有中文
  
  # 方式二：pip安装（需要Python 3.10+，推荐3.13）
  pip install vnpy
  pip install vnpy_ctastrategy
  pip install vnpy_ctabacktester
  pip install vnpy_datamanager
  pip install vnpy_sqlite  # 或 vnpy_mysql
  ```

- [ ] **TODO-P2-1.2** 验证vnpy安装
  ```python
  # 文件：test_vnpy_install.py
  from vnpy.event import EventEngine
  from vnpy.trader.engine import MainEngine
  from vnpy_ctastrategy import CtaStrategyApp
  from vnpy_ctabacktester import CtaBacktesterApp
  
  print("vnpy核心模块导入成功！")
  print(f"EventEngine: {EventEngine}")
  print(f"MainEngine: {MainEngine}")
  print(f"CtaStrategyApp: {CtaStrategyApp}")
  ```

- [ ] **TODO-P2-1.3** 理解vnpy项目结构
  ```markdown
  ## vnpy核心架构
  
  vnpy/
  ├── event/           # 事件引擎（核心）
  │   └── engine.py    # EventEngine类
  ├── trader/          # 交易核心
  │   ├── engine.py    # MainEngine主引擎
  │   ├── gateway.py   # 交易接口基类
  │   ├── object.py    # 数据对象定义
  │   └── constant.py  # 常量定义
  └── app/             # 应用模块
      ├── cta_strategy/     # CTA策略模块
      ├── cta_backtester/   # CTA回测模块
      └── data_manager/     # 数据管理模块
  
  ## 核心概念
  - EventEngine: 事件驱动引擎，所有模块通过事件通信
  - MainEngine: 主引擎，管理所有Gateway和App
  - Gateway: 交易接口（CTP、XTP等）
  - App: 功能模块（策略、回测等）
  ```

- [ ] **TODO-P2-1.4** 启动vnpy图形界面
  ```python
  # 文件：run_vnpy.py
  from vnpy.event import EventEngine
  from vnpy.trader.engine import MainEngine
  from vnpy.trader.ui import MainWindow, create_qapp
  
  from vnpy_ctastrategy import CtaStrategyApp
  from vnpy_ctabacktester import CtaBacktesterApp
  from vnpy_datamanager import DataManagerApp
  
  def main():
      """启动VeighNa Trader"""
      qapp = create_qapp()
      
      event_engine = EventEngine()
      main_engine = MainEngine(event_engine)
      
      # 添加应用模块
      main_engine.add_app(CtaStrategyApp)
      main_engine.add_app(CtaBacktesterApp)
      main_engine.add_app(DataManagerApp)
      
      main_window = MainWindow(main_engine, event_engine)
      main_window.showMaximized()
      
      qapp.exec()
  
  if __name__ == "__main__":
      main()
  ```

### Day 31-33：CTA策略开发基础

- [ ] **TODO-P2-2.1** 理解CTA策略模板
  ```python
  # 文件：~/quant_trading/vnpy_strategies/cta_template_study.py
  """
  CTA策略模板学习笔记
  
  核心组件：
  1. CtaTemplate - 策略基类
  2. BarGenerator - K线合成器
  3. ArrayManager - 技术指标计算器
  """
  
  from vnpy_ctastrategy import (
      CtaTemplate,
      StopOrder,
      BarGenerator,
      ArrayManager
  )
  from vnpy.trader.object import BarData, TickData, OrderData, TradeData
  from vnpy.trader.constant import Interval
  
  class TemplateStudy(CtaTemplate):
      """CTA策略模板学习"""
      
      author = "YourName"
      
      # 策略参数（可从外部配置）
      fast_window = 10
      slow_window = 30
      
      # 策略变量（运行时状态）
      fast_ma = 0.0
      slow_ma = 0.0
      
      # 参数和变量列表（用于UI显示和保存）
      parameters = ["fast_window", "slow_window"]
      variables = ["fast_ma", "slow_ma"]
      
      def __init__(self, cta_engine, strategy_name, vt_symbol, setting):
          """初始化"""
          super().__init__(cta_engine, strategy_name, vt_symbol, setting)
          
          # K线合成器：将Tick合成1分钟K线，再合成15分钟K线
          self.bg = BarGenerator(
              on_bar=self.on_bar,           # 1分钟K线回调
              window=15,                     # 合成窗口
              on_window_bar=self.on_15min_bar,  # 15分钟K线回调
              interval=Interval.MINUTE
          )
          
          # 技术指标计算器
          self.am = ArrayManager(size=100)  # 缓存100根K线
      
      def on_init(self):
          """策略初始化"""
          self.write_log("策略初始化")
          self.load_bar(10)  # 加载10天历史数据
      
      def on_start(self):
          """策略启动"""
          self.write_log("策略启动")
      
      def on_stop(self):
          """策略停止"""
          self.write_log("策略停止")
      
      def on_tick(self, tick: TickData):
          """Tick数据推送"""
          self.bg.update_tick(tick)
      
      def on_bar(self, bar: BarData):
          """1分钟K线推送"""
          self.bg.update_bar(bar)
      
      def on_15min_bar(self, bar: BarData):
          """15分钟K线推送（主要策略逻辑）"""
          # 更新K线到ArrayManager
          self.am.update_bar(bar)
          if not self.am.inited:
              return
          
          # 计算技术指标
          self.fast_ma = self.am.sma(self.fast_window)
          self.slow_ma = self.am.sma(self.slow_window)
          
          # 交易逻辑
          if self.pos == 0:
              if self.fast_ma > self.slow_ma:
                  self.buy(bar.close_price, 1)
              elif self.fast_ma < self.slow_ma:
                  self.short(bar.close_price, 1)
          elif self.pos > 0:
              if self.fast_ma < self.slow_ma:
                  self.sell(bar.close_price, abs(self.pos))
          elif self.pos < 0:
              if self.fast_ma > self.slow_ma:
                  self.cover(bar.close_price, abs(self.pos))
          
          # 同步数据到UI
          self.put_event()
      
      def on_order(self, order: OrderData):
          """委托回调"""
          pass
      
      def on_trade(self, trade: TradeData):
          """成交回调"""
          self.put_event()
      
      def on_stop_order(self, stop_order: StopOrder):
          """停止单回调"""
          pass
  ```

- [ ] **TODO-P2-2.2** 实现布林带CCI策略
  ```python
  # 文件：~/quant_trading/vnpy_strategies/boll_cci_strategy.py
  from vnpy_ctastrategy import (
      CtaTemplate,
      StopOrder,
      BarGenerator,
      ArrayManager
  )
  from vnpy.trader.object import BarData, TickData
  from vnpy.trader.constant import Interval
  
  class BollCciStrategy(CtaTemplate):
      """布林带+CCI策略"""
      
      author = "Quant Learner"
      
      # 策略参数
      boll_window = 18
      boll_dev = 3.4
      cci_window = 10
      atr_window = 30
      sl_multiplier = 5.2
      fixed_size = 1
      
      # 策略变量
      boll_up = 0.0
      boll_down = 0.0
      cci_value = 0.0
      atr_value = 0.0
      intra_trade_high = 0.0
      intra_trade_low = 0.0
      long_stop = 0.0
      short_stop = 0.0
      
      parameters = [
          "boll_window", "boll_dev", "cci_window",
          "atr_window", "sl_multiplier", "fixed_size"
      ]
      
      variables = [
          "boll_up", "boll_down", "cci_value", "atr_value",
          "intra_trade_high", "intra_trade_low", "long_stop", "short_stop"
      ]
      
      def __init__(self, cta_engine, strategy_name, vt_symbol, setting):
          super().__init__(cta_engine, strategy_name, vt_symbol, setting)
          
          self.bg = BarGenerator(
              on_bar=self.on_bar,
              window=15,
              on_window_bar=self.on_15min_bar,
              interval=Interval.MINUTE
          )
          self.am = ArrayManager()
      
      def on_init(self):
          self.write_log("策略初始化")
          self.load_bar(10)
      
      def on_start(self):
          self.write_log("策略启动")
      
      def on_stop(self):
          self.write_log("策略停止")
      
      def on_tick(self, tick: TickData):
          self.bg.update_tick(tick)
      
      def on_bar(self, bar: BarData):
          self.bg.update_bar(bar)
      
      def on_15min_bar(self, bar: BarData):
          self.cancel_all()
          
          am = self.am
          am.update_bar(bar)
          if not am.inited:
              return
          
          # 计算指标
          self.boll_up, self.boll_down = am.boll(self.boll_window, self.boll_dev)
          self.cci_value = am.cci(self.cci_window)
          self.atr_value = am.atr(self.atr_window)
          
          # 无持仓时
          if self.pos == 0:
              self.intra_trade_high = bar.high_price
              self.intra_trade_low = bar.low_price
              
              if self.cci_value > 0:
                  self.buy(self.boll_up, self.fixed_size, True)  # 停止单
              elif self.cci_value < 0:
                  self.short(self.boll_down, self.fixed_size, True)
          
          # 持多仓时
          elif self.pos > 0:
              self.intra_trade_high = max(self.intra_trade_high, bar.high_price)
              self.intra_trade_low = bar.low_price
              
              # ATR移动止损
              self.long_stop = self.intra_trade_high - self.atr_value * self.sl_multiplier
              self.sell(self.long_stop, abs(self.pos), True)
          
          # 持空仓时
          elif self.pos < 0:
              self.intra_trade_high = bar.high_price
              self.intra_trade_low = min(self.intra_trade_low, bar.low_price)
              
              self.short_stop = self.intra_trade_low + self.atr_value * self.sl_multiplier
              self.cover(self.short_stop, abs(self.pos), True)
          
          self.put_event()
  ```

- [ ] **TODO-P2-2.3** 理解ArrayManager指标计算
  ```python
  # 文件：~/quant_trading/vnpy_strategies/array_manager_study.py
  """
  ArrayManager常用方法学习
  """
  from vnpy_ctastrategy import ArrayManager
  import numpy as np
  
  # 创建ArrayManager实例
  am = ArrayManager(size=100)
  
  # 模拟更新K线数据
  # am.update_bar(bar)
  
  # 常用指标方法（假设am已初始化）
  """
  趋势指标：
  - am.sma(n)           # 简单移动平均
  - am.ema(n)           # 指数移动平均
  - am.macd(fast, slow, signal)  # MACD
  
  动量指标：
  - am.rsi(n)           # RSI
  - am.cci(n)           # CCI
  - am.willr(n)         # 威廉指标
  
  波动率指标：
  - am.atr(n)           # ATR
  - am.boll(n, dev)     # 布林带，返回(up, down)
  - am.keltner(n, dev)  # 肯特纳通道
  - am.donchian(n)      # 唐奇安通道，返回(up, down)
  
  成交量指标：
  - am.obv()            # OBV
  
  数组操作：
  - am.close            # 收盘价数组
  - am.high             # 最高价数组
  - am.low              # 最低价数组
  - am.open             # 开盘价数组
  - am.volume           # 成交量数组
  """
  
  print("ArrayManager学习完成")
  ```

### Day 34-35：vnpy本地回测

- [ ] **TODO-P2-3.1** 准备回测数据
  ```python
  # 文件：~/quant_trading/vnpy_data/prepare_backtest_data.py
  """
  准备vnpy回测数据
  将Tushare数据转换为vnpy格式并存入数据库
  """
  import pandas as pd
  from datetime import datetime
  from vnpy.trader.object import BarData
  from vnpy.trader.constant import Exchange, Interval
  from vnpy_sqlite.sqlite_database import SqliteDatabase
  
  def convert_tushare_to_vnpy(df: pd.DataFrame, symbol: str, exchange: Exchange) -> list:
      """将Tushare数据转换为vnpy BarData"""
      bars = []
      
      for _, row in df.iterrows():
          bar = BarData(
              symbol=symbol,
              exchange=exchange,
              datetime=pd.to_datetime(row['trade_date']),
              interval=Interval.DAILY,
              open_price=row['open'],
              high_price=row['high'],
              low_price=row['low'],
              close_price=row['close'],
              volume=row['vol'],
              turnover=row.get('amount', 0),
              gateway_name="BACKTEST"
          )
          bars.append(bar)
      
      return bars
  
  def save_to_vnpy_database(bars: list):
      """保存到vnpy数据库"""
      database = SqliteDatabase()
      database.save_bar_data(bars)
      print(f"保存 {len(bars)} 条K线数据")
  
  # 使用示例
  if __name__ == "__main__":
      import tushare as ts
      
      pro = ts.pro_api()
      
      # 获取数据
      df = pro.daily(ts_code='000001.SZ', start_date='20200101', end_date='20241201')
      
      # 转换并保存
      bars = convert_tushare_to_vnpy(df, "000001", Exchange.SZSE)
      save_to_vnpy_database(bars)
  ```

- [ ] **TODO-P2-3.2** 运行CTA回测
  ```python
  # 文件：~/quant_trading/vnpy_backtest/run_cta_backtest.py
  """
  vnpy CTA策略回测
  """
  from datetime import datetime
  from vnpy_ctabacktester.engine import BacktestingEngine
  from vnpy.trader.constant import Interval
  
  # 导入策略
  import sys
  sys.path.append('../vnpy_strategies')
  from boll_cci_strategy import BollCciStrategy
  
  def run_backtest():
      # 创建回测引擎
      engine = BacktestingEngine()
      
      # 设置回测参数
      engine.set_parameters(
          vt_symbol="000001.SZSE",
          interval=Interval.MINUTE,
          start=datetime(2022, 1, 1),
          end=datetime(2024, 12, 1),
          rate=0.0003,           # 手续费率
          slippage=0.2,          # 滑点
          size=100,              # 合约乘数
          pricetick=0.01,        # 最小价格变动
          capital=1_000_000,     # 初始资金
      )
      
      # 添加策略
      engine.add_strategy(BollCciStrategy, {
          "boll_window": 18,
          "boll_dev": 3.4,
          "cci_window": 10,
          "fixed_size": 1
      })
      
      # 加载数据
      engine.load_data()
      
      # 运行回测
      engine.run_backtesting()
      
      # 计算结果
      df = engine.calculate_result()
      statistics = engine.calculate_statistics()
      
      # 显示结果
      print("\n========== 回测统计 ==========")
      for key, value in statistics.items():
          print(f"{key}: {value}")
      
      # 绘制图表
      engine.show_chart()
      
      return statistics
  
  if __name__ == "__main__":
      run_backtest()
  ```

- [ ] **TODO-P2-3.3** 参数优化
  ```python
  # 文件：~/quant_trading/vnpy_backtest/optimize_strategy.py
  """
  vnpy策略参数优化
  """
  from datetime import datetime
  from vnpy_ctabacktester.engine import BacktestingEngine
  from vnpy.trader.constant import Interval
  from vnpy.trader.optimize import OptimizationSetting
  
  import sys
  sys.path.append('../vnpy_strategies')
  from boll_cci_strategy import BollCciStrategy
  
  def run_optimization():
      engine = BacktestingEngine()
      
      engine.set_parameters(
          vt_symbol="000001.SZSE",
          interval=Interval.MINUTE,
          start=datetime(2022, 1, 1),
          end=datetime(2024, 12, 1),
          rate=0.0003,
          slippage=0.2,
          size=100,
          pricetick=0.01,
          capital=1_000_000,
      )
      
      # 添加策略
      engine.add_strategy(BollCciStrategy, {})
      
      # 设置优化参数
      setting = OptimizationSetting()
      setting.set_target("sharpe_ratio")  # 优化目标
      setting.add_parameter("boll_window", 10, 30, 5)
      setting.add_parameter("boll_dev", 2.0, 4.0, 0.5)
      setting.add_parameter("cci_window", 5, 20, 5)
      
      # 运行优化（多进程）
      engine.run_ga_optimization(
          setting,
          output=True
      )
  
  if __name__ == "__main__":
      run_optimization()
  ```

#### 第五周完成检查点
- [ ] vnpy环境安装成功
- [ ] 理解CTA策略模板结构
- [ ] 完成布林带CCI策略开发
- [ ] 成功运行本地回测
- [ ] 完成一次参数优化

---

## 第六周：vnpy进阶 + 数据管理

### Day 36-38：多品种策略开发

- [ ] **TODO-P2-4.1** 实现跨品种套利策略框架
  ```python
  # 文件：~/quant_trading/vnpy_strategies/spread_strategy.py
  """
  价差套利策略框架
  """
  from vnpy_ctastrategy import CtaTemplate, BarGenerator, ArrayManager
  from vnpy.trader.object import BarData, TickData
  from collections import defaultdict
  
  class SpreadStrategy(CtaTemplate):
      """跨品种价差策略"""
      
      author = "Quant Learner"
      
      # 策略参数
      leg1_symbol = ""
      leg2_symbol = ""
      spread_mean = 0.0
      spread_std = 1.0
      entry_threshold = 2.0
      exit_threshold = 0.5
      fixed_size = 1
      
      # 策略变量
      spread_value = 0.0
      spread_zscore = 0.0
      
      parameters = [
          "leg1_symbol", "leg2_symbol",
          "spread_mean", "spread_std",
          "entry_threshold", "exit_threshold", "fixed_size"
      ]
      variables = ["spread_value", "spread_zscore"]
      
      def __init__(self, cta_engine, strategy_name, vt_symbol, setting):
          super().__init__(cta_engine, strategy_name, vt_symbol, setting)
          
          # 存储两腿数据
          self.leg1_price = 0.0
          self.leg2_price = 0.0
          
          self.bg = BarGenerator(self.on_bar)
          self.am = ArrayManager(size=100)
      
      def on_init(self):
          self.write_log("价差策略初始化")
          # 订阅两腿行情
          self.subscribe(self.leg1_symbol)
          self.subscribe(self.leg2_symbol)
          self.load_bar(10)
      
      def on_start(self):
          self.write_log("价差策略启动")
      
      def on_tick(self, tick: TickData):
          """处理Tick数据"""
          if tick.vt_symbol == self.leg1_symbol:
              self.leg1_price = tick.last_price
          elif tick.vt_symbol == self.leg2_symbol:
              self.leg2_price = tick.last_price
          
          # 计算价差
          if self.leg1_price > 0 and self.leg2_price > 0:
              self.spread_value = self.leg1_price - self.leg2_price
              self.spread_zscore = (self.spread_value - self.spread_mean) / self.spread_std
              
              self.check_signal()
      
      def check_signal(self):
          """检查交易信号"""
          if self.pos == 0:
              # 价差过大，做空价差
              if self.spread_zscore > self.entry_threshold:
                  self.short(self.leg1_symbol, self.leg1_price, self.fixed_size)
                  self.buy(self.leg2_symbol, self.leg2_price, self.fixed_size)
              # 价差过小，做多价差
              elif self.spread_zscore < -self.entry_threshold:
                  self.buy(self.leg1_symbol, self.leg1_price, self.fixed_size)
                  self.short(self.leg2_symbol, self.leg2_price, self.fixed_size)
          else:
              # 回归均值平仓
              if abs(self.spread_zscore) < self.exit_threshold:
                  self.close_all()
      
      def close_all(self):
          """平掉所有仓位"""
          # 实际实现需要根据持仓情况平仓
          pass
  ```

- [ ] **TODO-P2-4.2** 实现日内交易策略（带收盘平仓）
  ```python
  # 文件：~/quant_trading/vnpy_strategies/intraday_strategy.py
  """
  日内交易策略（收盘前平仓）
  """
  from datetime import time
  from vnpy_ctastrategy import CtaTemplate, BarGenerator, ArrayManager
  from vnpy.trader.object import BarData, TickData
  from vnpy.trader.constant import Interval
  
  class IntradayStrategy(CtaTemplate):
      """日内突破策略"""
      
      author = "Quant Learner"
      
      # 策略参数
      donchian_window = 20
      atr_window = 14
      risk_percent = 0.02
      exit_time = "14:50"
      
      # 策略变量
      day_high = 0.0
      day_low = 0.0
      atr_value = 0.0
      
      parameters = ["donchian_window", "atr_window", "risk_percent", "exit_time"]
      variables = ["day_high", "day_low", "atr_value"]
      
      def __init__(self, cta_engine, strategy_name, vt_symbol, setting):
          super().__init__(cta_engine, strategy_name, vt_symbol, setting)
          
          self.exit_hour, self.exit_minute = map(int, self.exit_time.split(":"))
          
          self.bg = BarGenerator(
              on_bar=self.on_bar,
              window=15,
              on_window_bar=self.on_15min_bar,
              interval=Interval.MINUTE
          )
          self.am = ArrayManager(size=100)
          
          # 每日状态
          self.traded_today = False
      
      def on_init(self):
          self.write_log("日内策略初始化")
          self.load_bar(10)
      
      def on_bar(self, bar: BarData):
          self.bg.update_bar(bar)
          
          # 检查是否需要收盘平仓
          if bar.datetime.hour == self.exit_hour and bar.datetime.minute >= self.exit_minute:
              if self.pos != 0:
                  self.write_log("收盘前平仓")
                  if self.pos > 0:
                      self.sell(bar.close_price, abs(self.pos))
                  else:
                      self.cover(bar.close_price, abs(self.pos))
              self.traded_today = False
          
          # 新的一天重置状态
          if bar.datetime.hour == 9 and bar.datetime.minute == 30:
              self.traded_today = False
      
      def on_15min_bar(self, bar: BarData):
          self.cancel_all()
          
          am = self.am
          am.update_bar(bar)
          if not am.inited:
              return
          
          # 计算指标
          self.day_high, self.day_low = am.donchian(self.donchian_window)
          self.atr_value = am.atr(self.atr_window)
          
          # 检查是否在交易时段
          current_time = bar.datetime.time()
          if current_time >= time(self.exit_hour, self.exit_minute):
              return
          
          # 交易逻辑
          if self.pos == 0 and not self.traded_today:
              if bar.close_price > self.day_high:
                  # 计算仓位
                  size = self.calculate_position(bar.close_price)
                  self.buy(bar.close_price, size)
                  self.traded_today = True
              elif bar.close_price < self.day_low:
                  size = self.calculate_position(bar.close_price)
                  self.short(bar.close_price, size)
                  self.traded_today = True
          
          self.put_event()
      
      def calculate_position(self, price: float) -> int:
          """基于风险计算仓位"""
          capital = 1_000_000  # 实际应从账户获取
          risk_amount = capital * self.risk_percent
          stop_distance = self.atr_value * 2
          
          if stop_distance <= 0:
              return 1
          
          size = int(risk_amount / stop_distance)
          return max(1, size)
  ```

### Day 39-40：时序数据库集成

- [ ] **TODO-P2-5.1** 安装配置TimescaleDB
  ```bash
  # 安装PostgreSQL和TimescaleDB
  # Ubuntu/Debian
  sudo apt install postgresql postgresql-contrib
  sudo apt install timescaledb-2-postgresql-14
  
  # 配置TimescaleDB
  sudo timescaledb-tune
  sudo systemctl restart postgresql
  
  # 创建数据库
  sudo -u postgres psql
  # CREATE DATABASE quant_data;
  # \c quant_data
  # CREATE EXTENSION IF NOT EXISTS timescaledb;
  ```

- [ ] **TODO-P2-5.2** 创建时序数据库管理模块
  ```python
  # 文件：~/quant_trading/database/timescale_manager.py
  """
  TimescaleDB数据管理
  """
  import pandas as pd
  from sqlalchemy import create_engine, text
  from datetime import datetime
  from typing import List, Optional
  
  class TimescaleManager:
      """TimescaleDB管理器"""
      
      def __init__(self, host: str = "localhost", port: int = 5432,
                   database: str = "quant_data", user: str = "postgres",
                   password: str = ""):
          self.engine = create_engine(
              f"postgresql://{user}:{password}@{host}:{port}/{database}"
          )
          self._init_tables()
      
      def _init_tables(self):
          """初始化数据表"""
          with self.engine.connect() as conn:
              # 创建K线表
              conn.execute(text("""
                  CREATE TABLE IF NOT EXISTS bar_data (
                      time TIMESTAMPTZ NOT NULL,
                      symbol VARCHAR(20) NOT NULL,
                      exchange VARCHAR(10) NOT NULL,
                      interval VARCHAR(10) NOT NULL,
                      open_price DOUBLE PRECISION,
                      high_price DOUBLE PRECISION,
                      low_price DOUBLE PRECISION,
                      close_price DOUBLE PRECISION,
                      volume DOUBLE PRECISION,
                      turnover DOUBLE PRECISION,
                      PRIMARY KEY (time, symbol, exchange, interval)
                  );
              """))
              
              # 转换为超表（TimescaleDB特性）
              conn.execute(text("""
                  SELECT create_hypertable('bar_data', 'time', 
                      if_not_exists => TRUE,
                      migrate_data => TRUE);
              """))
              
              # 创建因子表
              conn.execute(text("""
                  CREATE TABLE IF NOT EXISTS factor_data (
                      time TIMESTAMPTZ NOT NULL,
                      symbol VARCHAR(20) NOT NULL,
                      factor_name VARCHAR(50) NOT NULL,
                      factor_value DOUBLE PRECISION,
                      PRIMARY KEY (time, symbol, factor_name)
                  );
              """))
              
              conn.execute(text("""
                  SELECT create_hypertable('factor_data', 'time',
                      if_not_exists => TRUE,
                      migrate_data => TRUE);
              """))
              
              conn.commit()
      
      def save_bars(self, df: pd.DataFrame, symbol: str, exchange: str, 
                    interval: str = "1d"):
          """保存K线数据"""
          df = df.copy()
          df['symbol'] = symbol
          df['exchange'] = exchange
          df['interval'] = interval
          df['time'] = pd.to_datetime(df.index)
          
          columns = ['time', 'symbol', 'exchange', 'interval',
                    'open_price', 'high_price', 'low_price', 'close_price',
                    'volume', 'turnover']
          
          # 重命名列
          rename_map = {
              'open': 'open_price', 'high': 'high_price',
              'low': 'low_price', 'close': 'close_price',
              'vol': 'volume', 'amount': 'turnover'
          }
          df.rename(columns=rename_map, inplace=True)
          
          # 补充缺失列
          for col in columns:
              if col not in df.columns:
                  df[col] = 0
          
          df[columns].to_sql('bar_data', self.engine, 
                            if_exists='append', index=False,
                            method='multi')
          print(f"保存 {len(df)} 条K线数据")
      
      def load_bars(self, symbol: str, exchange: str, 
                    start: datetime, end: datetime,
                    interval: str = "1d") -> pd.DataFrame:
          """加载K线数据"""
          query = f"""
              SELECT * FROM bar_data
              WHERE symbol = '{symbol}'
              AND exchange = '{exchange}'
              AND interval = '{interval}'
              AND time >= '{start}'
              AND time <= '{end}'
              ORDER BY time
          """
          return pd.read_sql(query, self.engine, index_col='time')
      
      def save_factors(self, df: pd.DataFrame):
          """保存因子数据（宽表转长表）"""
          # df: index=date, columns=factor_name, 每行一只股票
          long_df = df.reset_index().melt(
              id_vars=['time', 'symbol'],
              var_name='factor_name',
              value_name='factor_value'
          )
          long_df.to_sql('factor_data', self.engine,
                        if_exists='append', index=False)
      
      def load_factors(self, symbols: List[str], factor_names: List[str],
                       start: datetime, end: datetime) -> pd.DataFrame:
          """加载因子数据"""
          symbols_str = "', '".join(symbols)
          factors_str = "', '".join(factor_names)
          
          query = f"""
              SELECT * FROM factor_data
              WHERE symbol IN ('{symbols_str}')
              AND factor_name IN ('{factors_str}')
              AND time >= '{start}'
              AND time <= '{end}'
              ORDER BY time, symbol
          """
          df = pd.read_sql(query, self.engine)
          
          # 转回宽表
          pivot = df.pivot_table(
              index=['time', 'symbol'],
              columns='factor_name',
              values='factor_value'
          ).reset_index()
          
          return pivot
  ```

- [ ] **TODO-P2-5.3** 批量数据入库脚本
  ```python
  # 文件：~/quant_trading/database/batch_import.py
  """
  批量导入股票数据到TimescaleDB
  """
  import tushare as ts
  from datetime import datetime
  from concurrent.futures import ThreadPoolExecutor
  from timescale_manager import TimescaleManager
  
  def import_stock_data(ts_code: str, manager: TimescaleManager,
                        start_date: str, end_date: str):
      """导入单只股票数据"""
      try:
          pro = ts.pro_api()
          df = pro.daily(ts_code=ts_code, start_date=start_date, end_date=end_date)
          
          if len(df) == 0:
              return f"{ts_code}: 无数据"
          
          # 设置索引
          df['trade_date'] = pd.to_datetime(df['trade_date'])
          df.set_index('trade_date', inplace=True)
          df.sort_index(inplace=True)
          
          # 解析symbol和exchange
          symbol = ts_code.split('.')[0]
          exchange = 'SZSE' if ts_code.endswith('.SZ') else 'SSE'
          
          manager.save_bars(df, symbol, exchange, '1d')
          return f"{ts_code}: 成功导入 {len(df)} 条"
      except Exception as e:
          return f"{ts_code}: 错误 - {str(e)}"
  
  def batch_import(stock_list: list, start_date: str, end_date: str,
                   max_workers: int = 5):
      """批量导入"""
      manager = TimescaleManager(password="your_password")
      
      results = []
      with ThreadPoolExecutor(max_workers=max_workers) as executor:
          futures = [
              executor.submit(import_stock_data, ts_code, manager, 
                            start_date, end_date)
              for ts_code in stock_list
          ]
          
          for future in futures:
              result = future.result()
              results.append(result)
              print(result)
      
      return results
  
  if __name__ == "__main__":
      # 获取沪深300成分股
      pro = ts.pro_api()
      hs300 = pro.index_weight(index_code='399300.SZ')
      stock_list = hs300['con_code'].unique().tolist()[:50]  # 先测试50只
      
      batch_import(stock_list, '20200101', '20241201')
  ```

#### 第六周完成检查点
- [ ] 实现跨品种策略框架
- [ ] 实现日内交易策略（带收盘平仓）
- [ ] 配置TimescaleDB
- [ ] 完成批量数据入库
- [ ] 数据读写正常

---

## 第七周：多因子模型进阶

### Day 41-43：因子合成方法

- [ ] **TODO-P2-6.1** 实现多种因子合成方法
  ```python
  # 文件：~/quant_trading/factors/factor_combiner.py
  """
  多因子合成方法
  """
  import pandas as pd
  import numpy as np
  from sklearn.linear_model import LinearRegression, Ridge, Lasso
  from sklearn.ensemble import RandomForestRegressor, GradientBoostingRegressor
  from typing import Dict, List, Callable
  
  class FactorCombiner:
      """因子合成器"""
      
      def __init__(self, factor_data: pd.DataFrame, return_data: pd.Series):
          """
          factor_data: DataFrame, columns为因子名，index为日期
          return_data: Series, 未来收益率
          """
          self.factors = factor_data
          self.returns = return_data
          self.weights = None
      
      def equal_weight(self) -> pd.Series:
          """等权合成"""
          self.weights = pd.Series(
              1.0 / len(self.factors.columns),
              index=self.factors.columns
          )
          return (self.factors * self.weights).sum(axis=1)
      
      def ic_weight(self, lookback: int = 60) -> pd.Series:
          """IC加权合成"""
          # 计算滚动IC
          ic_dict = {}
          for col in self.factors.columns:
              ic_series = self.factors[col].rolling(lookback).corr(self.returns)
              ic_dict[col] = ic_series.mean()
          
          # IC作为权重（取绝对值，保持方向）
          ic_values = pd.Series(ic_dict)
          self.weights = ic_values / ic_values.abs().sum()
          
          return (self.factors * self.weights).sum(axis=1)
      
      def icir_weight(self, lookback: int = 60) -> pd.Series:
          """IC_IR加权合成"""
          icir_dict = {}
          for col in self.factors.columns:
              ic_series = self.factors[col].rolling(lookback).corr(self.returns)
              ic_mean = ic_series.mean()
              ic_std = ic_series.std()
              icir_dict[col] = ic_mean / ic_std if ic_std > 0 else 0
          
          icir_values = pd.Series(icir_dict)
          self.weights = icir_values / icir_values.abs().sum()
          
          return (self.factors * self.weights).sum(axis=1)
      
      def regression_weight(self, method: str = 'ols') -> pd.Series:
          """回归法合成"""
          X = self.factors.dropna()
          y = self.returns.loc[X.index]
          
          if method == 'ols':
              model = LinearRegression()
          elif method == 'ridge':
              model = Ridge(alpha=1.0)
          elif method == 'lasso':
              model = Lasso(alpha=0.1)
          else:
              raise ValueError(f"未知方法: {method}")
          
          model.fit(X, y)
          self.weights = pd.Series(model.coef_, index=self.factors.columns)
          
          return (self.factors * self.weights).sum(axis=1)
      
      def ml_weight(self, method: str = 'rf') -> pd.Series:
          """机器学习合成"""
          X = self.factors.dropna()
          y = self.returns.loc[X.index]
          
          if method == 'rf':
              model = RandomForestRegressor(n_estimators=100, random_state=42)
          elif method == 'gbdt':
              model = GradientBoostingRegressor(n_estimators=100, random_state=42)
          else:
              raise ValueError(f"未知方法: {method}")
          
          model.fit(X, y)
          
          # 特征重要性作为权重
          importance = model.feature_importances_
          self.weights = pd.Series(importance, index=self.factors.columns)
          self.weights = self.weights / self.weights.sum()
          
          # 返回模型预测值
          return pd.Series(model.predict(self.factors), index=self.factors.index)
      
      def get_weights(self) -> pd.Series:
          """获取当前权重"""
          return self.weights
  ```

- [ ] **TODO-P2-6.2** 实现因子正交化
  ```python
  # 文件：~/quant_trading/factors/factor_orthogonalize.py
  """
  因子正交化处理
  消除因子间的多重共线性
  """
  import pandas as pd
  import numpy as np
  from sklearn.linear_model import LinearRegression
  from scipy import stats
  
  class FactorOrthogonalizer:
      """因子正交化器"""
      
      def __init__(self, factor_data: pd.DataFrame):
          """
          factor_data: DataFrame, columns为因子名
          """
          self.original_factors = factor_data
          self.orthogonal_factors = None
      
      def symmetric_orthogonalize(self) -> pd.DataFrame:
          """对称正交化（Löwdin正交化）"""
          X = self.original_factors.dropna().values
          
          # 计算协方差矩阵
          cov = np.cov(X.T)
          
          # 特征分解
          eigenvalues, eigenvectors = np.linalg.eigh(cov)
          
          # 计算S^(-1/2)
          S_inv_sqrt = eigenvectors @ np.diag(1.0 / np.sqrt(eigenvalues)) @ eigenvectors.T
          
          # 正交化
          X_orth = X @ S_inv_sqrt
          
          self.orthogonal_factors = pd.DataFrame(
              X_orth,
              index=self.original_factors.dropna().index,
              columns=self.original_factors.columns
          )
          return self.orthogonal_factors
      
      def sequential_orthogonalize(self, order: list = None) -> pd.DataFrame:
          """顺序正交化（Gram-Schmidt）"""
          if order is None:
              order = self.original_factors.columns.tolist()
          
          df = self.original_factors[order].dropna()
          result = pd.DataFrame(index=df.index)
          
          for i, col in enumerate(order):
              if i == 0:
                  result[col] = df[col]
              else:
                  # 回归残差
                  X = result.iloc[:, :i].values
                  y = df[col].values
                  
                  model = LinearRegression()
                  model.fit(X, y)
                  residual = y - model.predict(X)
                  
                  result[col] = residual
          
          # 标准化
          self.orthogonal_factors = (result - result.mean()) / result.std()
          return self.orthogonal_factors
      
      def check_orthogonality(self) -> pd.DataFrame:
          """检查正交性（相关矩阵）"""
          if self.orthogonal_factors is None:
              raise ValueError("请先进行正交化")
          
          return self.orthogonal_factors.corr()
  ```

### Day 44-45：机器学习选股模型

- [ ] **TODO-P2-7.1** 实现LightGBM选股模型
  ```python
  # 文件：~/quant_trading/models/lgbm_selector.py
  """
  LightGBM选股模型
  """
  import pandas as pd
  import numpy as np
  import lightgbm as lgb
  from sklearn.model_selection import TimeSeriesSplit
  from sklearn.metrics import mean_squared_error, r2_score
  from typing import Dict, Tuple
  
  class LGBMStockSelector:
      """LightGBM选股模型"""
      
      def __init__(self, params: Dict = None):
          self.default_params = {
              'objective': 'regression',
              'metric': 'mse',
              'boosting_type': 'gbdt',
              'num_leaves': 31,
              'learning_rate': 0.05,
              'feature_fraction': 0.8,
              'bagging_fraction': 0.8,
              'bagging_freq': 5,
              'verbose': -1,
              'n_estimators': 100
          }
          self.params = {**self.default_params, **(params or {})}
          self.model = None
          self.feature_importance = None
      
      def prepare_data(self, factor_data: pd.DataFrame, 
                       return_data: pd.Series,
                       label_shift: int = 1) -> Tuple[pd.DataFrame, pd.Series]:
          """准备训练数据"""
          # 对齐数据
          X = factor_data.copy()
          y = return_data.shift(-label_shift)  # 预测未来收益
          
          # 去除NaN
          valid_idx = X.dropna().index.intersection(y.dropna().index)
          X = X.loc[valid_idx]
          y = y.loc[valid_idx]
          
          return X, y
      
      def train(self, X: pd.DataFrame, y: pd.Series, 
                n_splits: int = 5) -> Dict:
          """时间序列交叉验证训练"""
          tscv = TimeSeriesSplit(n_splits=n_splits)
          
          cv_scores = []
          feature_importances = []
          
          for fold, (train_idx, val_idx) in enumerate(tscv.split(X)):
              X_train, X_val = X.iloc[train_idx], X.iloc[val_idx]
              y_train, y_val = y.iloc[train_idx], y.iloc[val_idx]
              
              # 创建数据集
              train_data = lgb.Dataset(X_train, label=y_train)
              val_data = lgb.Dataset(X_val, label=y_val, reference=train_data)
              
              # 训练
              model = lgb.train(
                  self.params,
                  train_data,
                  valid_sets=[train_data, val_data],
                  callbacks=[lgb.early_stopping(10), lgb.log_evaluation(0)]
              )
              
              # 验证
              y_pred = model.predict(X_val)
              mse = mean_squared_error(y_val, y_pred)
              r2 = r2_score(y_val, y_pred)
              
              cv_scores.append({'fold': fold, 'mse': mse, 'r2': r2})
              feature_importances.append(
                  pd.Series(model.feature_importance(), index=X.columns)
              )
              
              print(f"Fold {fold}: MSE={mse:.6f}, R2={r2:.4f}")
          
          # 使用全量数据训练最终模型
          train_data = lgb.Dataset(X, label=y)
          self.model = lgb.train(self.params, train_data)
          
          # 平均特征重要性
          self.feature_importance = pd.concat(feature_importances, axis=1).mean(axis=1)
          self.feature_importance = self.feature_importance.sort_values(ascending=False)
          
          return {
              'cv_scores': pd.DataFrame(cv_scores),
              'feature_importance': self.feature_importance
          }
      
      def predict(self, X: pd.DataFrame) -> pd.Series:
          """预测"""
          if self.model is None:
              raise ValueError("请先训练模型")
          
          predictions = self.model.predict(X)
          return pd.Series(predictions, index=X.index)
      
      def select_stocks(self, X: pd.DataFrame, top_n: int = 20) -> list:
          """选股"""
          predictions = self.predict(X)
          return predictions.nlargest(top_n).index.tolist()
      
      def get_feature_importance(self) -> pd.Series:
          """获取特征重要性"""
          return self.feature_importance
  ```

- [ ] **TODO-P2-7.2** 实现滚动训练框架
  ```python
  # 文件：~/quant_trading/models/rolling_trainer.py
  """
  滚动训练框架
  """
  import pandas as pd
  import numpy as np
  from datetime import datetime, timedelta
  from typing import Callable, Dict, List
  from lgbm_selector import LGBMStockSelector
  
  class RollingTrainer:
      """滚动训练器"""
      
      def __init__(self, 
                   train_window: int = 252,  # 训练窗口（交易日）
                   valid_window: int = 21,   # 验证窗口
                   retrain_freq: int = 21):  # 重训练频率
          self.train_window = train_window
          self.valid_window = valid_window
          self.retrain_freq = retrain_freq
          self.models = {}
          self.predictions = []
      
      def run(self, factor_data: pd.DataFrame, 
              return_data: pd.Series,
              model_class: type = LGBMStockSelector) -> pd.DataFrame:
          """
          滚动训练和预测
          factor_data: 因子数据，index为日期
          return_data: 收益率数据
          """
          dates = factor_data.index.unique().sort_values()
          
          results = []
          
          for i in range(self.train_window, len(dates) - self.valid_window, self.retrain_freq):
              train_end = dates[i]
              train_start = dates[max(0, i - self.train_window)]
              pred_start = dates[i + 1]
              pred_end = dates[min(i + self.valid_window, len(dates) - 1)]
              
              print(f"\n训练期: {train_start} ~ {train_end}")
              print(f"预测期: {pred_start} ~ {pred_end}")
              
              # 准备训练数据
              train_mask = (factor_data.index >= train_start) & (factor_data.index <= train_end)
              X_train = factor_data[train_mask]
              y_train = return_data[train_mask]
              
              # 训练模型
              model = model_class()
              X_prepared, y_prepared = model.prepare_data(X_train, y_train)
              model.train(X_prepared, y_prepared, n_splits=3)
              
              # 预测
              pred_mask = (factor_data.index >= pred_start) & (factor_data.index <= pred_end)
              X_pred = factor_data[pred_mask]
              
              if len(X_pred) > 0:
                  predictions = model.predict(X_pred.dropna())
                  
                  for date in predictions.index:
                      results.append({
                          'date': date,
                          'prediction': predictions[date],
                          'actual': return_data.get(date, np.nan),
                          'train_end': train_end
                      })
              
              # 保存模型
              self.models[train_end] = model
          
          return pd.DataFrame(results)
      
      def evaluate(self, results: pd.DataFrame) -> Dict:
          """评估滚动预测结果"""
          valid_results = results.dropna()
          
          # IC
          ic = valid_results['prediction'].corr(valid_results['actual'])
          
          # 分组收益
          valid_results['quantile'] = pd.qcut(
              valid_results['prediction'], 5, labels=False, duplicates='drop'
          )
          quantile_returns = valid_results.groupby('quantile')['actual'].mean()
          
          # 多空收益
          long_short = quantile_returns.iloc[-1] - quantile_returns.iloc[0]
          
          return {
              'IC': ic,
              'quantile_returns': quantile_returns,
              'long_short_return': long_short
          }
  ```

- [ ] **TODO-P2-7.3** 机器学习选股实践
  ```python
  # 文件：notebooks/08_ml_stock_selection.ipynb
  """
  机器学习选股实践
  
  流程：
  1. 准备因子数据
  2. 训练LightGBM模型
  3. 滚动预测
  4. 评估模型表现
  5. 构建选股策略
  """
  # 练习内容
  ```

#### 第七周完成检查点
- [ ] 实现3种以上因子合成方法
- [ ] 完成因子正交化处理
- [ ] LightGBM选股模型可运行
- [ ] 滚动训练框架完成
- [ ] 机器学习选股回测完成

---

## 第八周：风险管理体系

### Day 46-48：完整风控模块

- [ ] **TODO-P2-8.1** 实现多层次风控系统
  ```python
  # 文件：~/quant_trading/risk/risk_manager.py
  """
  多层次风险管理系统
  """
  import pandas as pd
  import numpy as np
  from dataclasses import dataclass
  from typing import Dict, List, Optional
  from enum import Enum
  from datetime import datetime
  
  class RiskLevel(Enum):
      NORMAL = "normal"
      WARNING = "warning"
      CRITICAL = "critical"
      HALT = "halt"
  
  @dataclass
  class RiskAlert:
      level: RiskLevel
      rule_name: str
      message: str
      timestamp: datetime
      data: Dict
  
  class RiskRule:
      """风控规则基类"""
      def __init__(self, name: str, threshold: float):
          self.name = name
          self.threshold = threshold
      
      def check(self, data: Dict) -> Optional[RiskAlert]:
          raise NotImplementedError
  
  class SingleTradeRiskRule(RiskRule):
      """单笔交易风险规则"""
      def __init__(self, max_loss_pct: float = 0.02):
          super().__init__("single_trade_risk", max_loss_pct)
      
      def check(self, data: Dict) -> Optional[RiskAlert]:
          trade_pnl_pct = data.get('trade_pnl_pct', 0)
          
          if trade_pnl_pct < -self.threshold:
              return RiskAlert(
                  level=RiskLevel.WARNING,
                  rule_name=self.name,
                  message=f"单笔亏损超限: {trade_pnl_pct:.2%} > {self.threshold:.2%}",
                  timestamp=datetime.now(),
                  data=data
              )
          return None
  
  class DailyLossRule(RiskRule):
      """单日亏损规则"""
      def __init__(self, max_daily_loss: float = 0.05):
          super().__init__("daily_loss", max_daily_loss)
      
      def check(self, data: Dict) -> Optional[RiskAlert]:
          daily_pnl_pct = data.get('daily_pnl_pct', 0)
          
          if daily_pnl_pct < -self.threshold:
              return RiskAlert(
                  level=RiskLevel.CRITICAL,
                  rule_name=self.name,
                  message=f"单日亏损触发熔断: {daily_pnl_pct:.2%}",
                  timestamp=datetime.now(),
                  data=data
              )
          return None
  
  class DrawdownRule(RiskRule):
      """回撤规则"""
      def __init__(self, max_drawdown: float = 0.15, halt_drawdown: float = 0.20):
          super().__init__("drawdown", max_drawdown)
          self.halt_drawdown = halt_drawdown
      
      def check(self, data: Dict) -> Optional[RiskAlert]:
          current_drawdown = data.get('current_drawdown', 0)
          
          if current_drawdown < -self.halt_drawdown:
              return RiskAlert(
                  level=RiskLevel.HALT,
                  rule_name=self.name,
                  message=f"回撤触发清仓: {current_drawdown:.2%}",
                  timestamp=datetime.now(),
                  data=data
              )
          elif current_drawdown < -self.threshold:
              return RiskAlert(
                  level=RiskLevel.WARNING,
                  rule_name=self.name,
                  message=f"回撤预警: {current_drawdown:.2%}",
                  timestamp=datetime.now(),
                  data=data
              )
          return None
  
  class ConcentrationRule(RiskRule):
      """集中度规则"""
      def __init__(self, max_single_position: float = 0.20):
          super().__init__("concentration", max_single_position)
      
      def check(self, data: Dict) -> Optional[RiskAlert]:
          positions = data.get('positions', {})
          total_value = data.get('total_value', 1)
          
          for symbol, value in positions.items():
              weight = value / total_value
              if weight > self.threshold:
                  return RiskAlert(
                      level=RiskLevel.WARNING,
                      rule_name=self.name,
                      message=f"持仓集中度超限: {symbol} = {weight:.2%}",
                      timestamp=datetime.now(),
                      data={'symbol': symbol, 'weight': weight}
                  )
          return None
  
  class RiskManager:
      """风险管理器"""
      
      def __init__(self):
          self.rules: List[RiskRule] = []
          self.alerts: List[RiskAlert] = []
          self.is_halted = False
          
          # 账户状态
          self.initial_capital = 0
          self.current_capital = 0
          self.high_water_mark = 0
          self.daily_starting_capital = 0
          self.positions = {}
      
      def add_rule(self, rule: RiskRule):
          """添加风控规则"""
          self.rules.append(rule)
      
      def initialize(self, capital: float):
          """初始化"""
          self.initial_capital = capital
          self.current_capital = capital
          self.high_water_mark = capital
          self.daily_starting_capital = capital
      
      def update(self, current_capital: float, positions: Dict[str, float]):
          """更新状态"""
          self.current_capital = current_capital
          self.positions = positions
          
          # 更新高水位
          if current_capital > self.high_water_mark:
              self.high_water_mark = current_capital
      
      def new_day(self):
          """新的一天"""
          self.daily_starting_capital = self.current_capital
      
      def check_all_rules(self) -> List[RiskAlert]:
          """检查所有风控规则"""
          if self.is_halted:
              return []
          
          # 准备检查数据
          data = {
              'current_capital': self.current_capital,
              'daily_pnl_pct': (self.current_capital - self.daily_starting_capital) / self.daily_starting_capital,
              'current_drawdown': (self.current_capital - self.high_water_mark) / self.high_water_mark,
              'positions': self.positions,
              'total_value': self.current_capital
          }
          
          new_alerts = []
          for rule in self.rules:
              alert = rule.check(data)
              if alert:
                  new_alerts.append(alert)
                  self.alerts.append(alert)
                  
                  if alert.level == RiskLevel.HALT:
                      self.is_halted = True
          
          return new_alerts
      
      def check_trade(self, trade_pnl: float) -> Optional[RiskAlert]:
          """检查单笔交易"""
          trade_pnl_pct = trade_pnl / self.current_capital
          
          data = {'trade_pnl_pct': trade_pnl_pct}
          
          for rule in self.rules:
              if isinstance(rule, SingleTradeRiskRule):
                  alert = rule.check(data)
                  if alert:
                      self.alerts.append(alert)
                      return alert
          return None
      
      def get_status(self) -> Dict:
          """获取风控状态"""
          return {
              'is_halted': self.is_halted,
              'current_drawdown': (self.current_capital - self.high_water_mark) / self.high_water_mark,
              'daily_pnl': (self.current_capital - self.daily_starting_capital) / self.daily_starting_capital,
              'total_pnl': (self.current_capital - self.initial_capital) / self.initial_capital,
              'alert_count': len(self.alerts),
              'last_alert': self.alerts[-1] if self.alerts else None
          }
  ```

- [ ] **TODO-P2-8.2** 实现仓位管理模块
  ```python
  # 文件：~/quant_trading/risk/position_manager.py
  """
  仓位管理模块
  """
  import numpy as np
  import pandas as pd
  from typing import Dict, Optional
  from dataclasses import dataclass
  
  @dataclass
  class PositionSizing:
      """仓位计算结果"""
      target_size: int
      target_value: float
      risk_amount: float
      stop_loss: float
      method: str
  
  class PositionManager:
      """仓位管理器"""
      
      def __init__(self, 
                   total_capital: float,
                   max_position_pct: float = 0.20,
                   max_total_exposure: float = 0.80):
          self.total_capital = total_capital
          self.max_position_pct = max_position_pct
          self.max_total_exposure = max_total_exposure
          self.positions: Dict[str, float] = {}
      
      def fixed_amount(self, amount: float, price: float) -> PositionSizing:
          """固定金额"""
          size = int(amount / price / 100) * 100  # A股最小单位100股
          return PositionSizing(
              target_size=size,
              target_value=size * price,
              risk_amount=0,
              stop_loss=0,
              method='fixed_amount'
          )
      
      def fixed_ratio(self, ratio: float, price: float) -> PositionSizing:
          """固定比例"""
          amount = self.total_capital * ratio
          return self.fixed_amount(amount, price)
      
      def risk_parity(self, price: float, stop_loss: float, 
                      risk_per_trade: float = 0.02) -> PositionSizing:
          """风险平价（基于止损）"""
          risk_amount = self.total_capital * risk_per_trade
          stop_distance = abs(price - stop_loss)
          
          if stop_distance <= 0:
              return self.fixed_ratio(0.05, price)
          
          shares = risk_amount / stop_distance
          size = int(shares / 100) * 100
          
          return PositionSizing(
              target_size=size,
              target_value=size * price,
              risk_amount=risk_amount,
              stop_loss=stop_loss,
              method='risk_parity'
          )
      
      def volatility_adjusted(self, price: float, volatility: float,
                              target_vol: float = 0.15) -> PositionSizing:
          """波动率调整"""
          # 根据波动率调整仓位
          vol_ratio = target_vol / volatility if volatility > 0 else 1
          adjusted_ratio = min(self.max_position_pct, 0.10 * vol_ratio)
          
          return self.fixed_ratio(adjusted_ratio, price)
      
      def kelly_criterion(self, win_rate: float, win_loss_ratio: float,
                          price: float, fraction: float = 0.5) -> PositionSizing:
          """凯利公式（半凯利）"""
          # f* = (p*b - q) / b
          # p = 胜率, q = 1-p, b = 盈亏比
          p = win_rate
          q = 1 - p
          b = win_loss_ratio
          
          kelly = (p * b - q) / b if b > 0 else 0
          kelly = max(0, min(kelly, 0.25))  # 限制最大25%
          
          # 使用半凯利
          kelly *= fraction
          
          return self.fixed_ratio(kelly, price)
      
      def check_position_limit(self, symbol: str, 
                               sizing: PositionSizing) -> PositionSizing:
          """检查仓位限制"""
          # 检查单个持仓上限
          max_value = self.total_capital * self.max_position_pct
          if sizing.target_value > max_value:
              new_size = int(max_value / (sizing.target_value / sizing.target_size) / 100) * 100
              sizing.target_size = new_size
              sizing.target_value = new_size * (sizing.target_value / sizing.target_size)
          
          # 检查总仓位上限
          current_exposure = sum(self.positions.values())
          available = self.total_capital * self.max_total_exposure - current_exposure
          
          if sizing.target_value > available:
              ratio = available / sizing.target_value
              sizing.target_size = int(sizing.target_size * ratio / 100) * 100
              sizing.target_value = sizing.target_size * (sizing.target_value / sizing.target_size)
          
          return sizing
      
      def update_position(self, symbol: str, value: float):
          """更新持仓"""
          if value > 0:
              self.positions[symbol] = value
          elif symbol in self.positions:
              del self.positions[symbol]
      
      def get_current_exposure(self) -> float:
          """获取当前总仓位"""
          return sum(self.positions.values()) / self.total_capital
  ```

### Day 49-50：风控集成到策略

- [ ] **TODO-P2-9.1** 创建带风控的策略模板
  ```python
  # 文件：~/quant_trading/vnpy_strategies/risk_controlled_strategy.py
  """
  带风控的策略模板
  """
  from vnpy_ctastrategy import CtaTemplate, BarGenerator, ArrayManager
  from vnpy.trader.object import BarData, TickData, TradeData
  from vnpy.trader.constant import Interval
  import sys
  sys.path.append('../risk')
  from risk_manager import RiskManager, SingleTradeRiskRule, DailyLossRule, DrawdownRule
  from position_manager import PositionManager
  
  class RiskControlledStrategy(CtaTemplate):
      """带完整风控的CTA策略"""
      
      author = "Quant Learner"
      
      # 策略参数
      fast_window = 10
      slow_window = 30
      atr_window = 14
      risk_per_trade = 0.02
      max_position_pct = 0.20
      
      # 策略变量
      fast_ma = 0.0
      slow_ma = 0.0
      atr_value = 0.0
      current_drawdown = 0.0
      
      parameters = ["fast_window", "slow_window", "atr_window", 
                    "risk_per_trade", "max_position_pct"]
      variables = ["fast_ma", "slow_ma", "atr_value", "current_drawdown"]
      
      def __init__(self, cta_engine, strategy_name, vt_symbol, setting):
          super().__init__(cta_engine, strategy_name, vt_symbol, setting)
          
          self.bg = BarGenerator(
              on_bar=self.on_bar,
              window=15,
              on_window_bar=self.on_15min_bar,
              interval=Interval.MINUTE
          )
          self.am = ArrayManager()
          
          # 初始化风控模块
          self.risk_manager = RiskManager()
          self.risk_manager.add_rule(SingleTradeRiskRule(0.02))
          self.risk_manager.add_rule(DailyLossRule(0.05))
          self.risk_manager.add_rule(DrawdownRule(0.15, 0.20))
          
          # 初始化仓位管理
          self.position_manager = None  # 在on_init中初始化
          
          # 交易状态
          self.entry_price = 0
          self.stop_loss_price = 0
      
      def on_init(self):
          self.write_log("策略初始化")
          
          # 获取账户资金（实际应从引擎获取）
          capital = 1_000_000
          
          self.risk_manager.initialize(capital)
          self.position_manager = PositionManager(
              capital, 
              self.max_position_pct
          )
          
          self.load_bar(10)
      
      def on_start(self):
          self.write_log("策略启动")
      
      def on_stop(self):
          self.write_log("策略停止")
      
      def on_bar(self, bar: BarData):
          self.bg.update_bar(bar)
          
          # 每日开盘重置
          if bar.datetime.hour == 9 and bar.datetime.minute == 30:
              self.risk_manager.new_day()
      
      def on_15min_bar(self, bar: BarData):
          self.cancel_all()
          
          # 检查风控状态
          if self.risk_manager.is_halted:
              self.write_log("风控触发，策略暂停")
              if self.pos != 0:
                  self.close_all_positions(bar)
              return
          
          am = self.am
          am.update_bar(bar)
          if not am.inited:
              return
          
          # 计算指标
          self.fast_ma = am.sma(self.fast_window)
          self.slow_ma = am.sma(self.slow_window)
          self.atr_value = am.atr(self.atr_window)
          
          # 更新风控状态
          current_capital = self.get_current_capital(bar.close_price)
          self.risk_manager.update(current_capital, {})
          
          # 检查风控规则
          alerts = self.risk_manager.check_all_rules()
          for alert in alerts:
              self.write_log(f"风控告警: {alert.message}")
          
          # 更新回撤显示
          status = self.risk_manager.get_status()
          self.current_drawdown = status['current_drawdown']
          
          # 交易逻辑
          self.execute_trading_logic(bar)
          
          self.put_event()
      
      def execute_trading_logic(self, bar: BarData):
          """执行交易逻辑"""
          if self.pos == 0:
              # 开仓逻辑
              if self.fast_ma > self.slow_ma:
                  # 计算止损价
                  stop_loss = bar.close_price - 2 * self.atr_value
                  
                  # 基于风险计算仓位
                  sizing = self.position_manager.risk_parity(
                      bar.close_price, stop_loss, self.risk_per_trade
                  )
                  
                  # 检查仓位限制
                  sizing = self.position_manager.check_position_limit(
                      self.vt_symbol, sizing
                  )
                  
                  if sizing.target_size > 0:
                      self.buy(bar.close_price, sizing.target_size)
                      self.entry_price = bar.close_price
                      self.stop_loss_price = stop_loss
                      
              elif self.fast_ma < self.slow_ma:
                  stop_loss = bar.close_price + 2 * self.atr_value
                  
                  sizing = self.position_manager.risk_parity(
                      bar.close_price, stop_loss, self.risk_per_trade
                  )
                  sizing = self.position_manager.check_position_limit(
                      self.vt_symbol, sizing
                  )
                  
                  if sizing.target_size > 0:
                      self.short(bar.close_price, sizing.target_size)
                      self.entry_price = bar.close_price
                      self.stop_loss_price = stop_loss
          
          else:
              # 持仓管理
              if self.pos > 0:
                  # 移动止损
                  new_stop = bar.close_price - 2 * self.atr_value
                  if new_stop > self.stop_loss_price:
                      self.stop_loss_price = new_stop
                  
                  # 触发止损
                  if bar.close_price < self.stop_loss_price:
                      self.sell(bar.close_price, abs(self.pos))
                  # 趋势反转
                  elif self.fast_ma < self.slow_ma:
                      self.sell(bar.close_price, abs(self.pos))
              
              elif self.pos < 0:
                  new_stop = bar.close_price + 2 * self.atr_value
                  if new_stop < self.stop_loss_price:
                      self.stop_loss_price = new_stop
                  
                  if bar.close_price > self.stop_loss_price:
                      self.cover(bar.close_price, abs(self.pos))
                  elif self.fast_ma > self.slow_ma:
                      self.cover(bar.close_price, abs(self.pos))
      
      def on_trade(self, trade: TradeData):
          """成交回调"""
          # 计算交易盈亏
          if self.entry_price > 0:
              if trade.direction.value == "多":
                  pnl = (trade.price - self.entry_price) * trade.volume
              else:
                  pnl = (self.entry_price - trade.price) * trade.volume
              
              # 检查单笔交易风控
              alert = self.risk_manager.check_trade(pnl)
              if alert:
                  self.write_log(f"交易风控: {alert.message}")
          
          self.put_event()
      
      def get_current_capital(self, current_price: float) -> float:
          """获取当前资金（简化计算）"""
          # 实际应该从账户获取
          return 1_000_000 + self.pos * current_price
      
      def close_all_positions(self, bar: BarData):
          """平掉所有仓位"""
          if self.pos > 0:
              self.sell(bar.close_price, abs(self.pos))
          elif self.pos < 0:
              self.cover(bar.close_price, abs(self.pos))
  ```

#### 第八周完成检查点
- [ ] 多层次风控系统完成
- [ ] 仓位管理模块完成
- [ ] 风控集成到策略模板
- [ ] 风控回测验证通过

---

## 第九周：QMT模拟交易

### Day 51-53：QMT环境配置

- [ ] **TODO-P2-10.1** QMT安装配置
  ```markdown
  ## QMT安装步骤
  
  1. 券商开户并申请QMT权限
  2. 下载MiniQMT客户端
  3. 安装到无中文路径目录
  4. 配置Python环境
  5. 测试登录
  ```

- [ ] **TODO-P2-10.2** 将策略迁移到QMT
  ```python
  # 文件：qmt_strategies/dual_ma_strategy.py
  """
  QMT双均线策略
  """
  
  def init(context):
      """初始化"""
      context.symbol = '000001.SZ'
      context.fast_period = 10
      context.slow_period = 30
      context.position_ratio = 0.5
      
      # 风控参数
      context.max_drawdown = 0.15
      context.daily_loss_limit = 0.05
      context.high_water_mark = context.portfolio.total_value
      
      run_daily(before_market, '09:25')
      run_daily(market_open, '09:35')
      run_daily(check_risk, '10:00')
      run_daily(check_risk, '14:00')
      run_daily(market_close, '14:50')
  
  def before_market(context):
      """盘前准备"""
      context.daily_start_value = context.portfolio.total_value
      context.traded_today = False
      log.info(f"盘前净值: {context.daily_start_value:.2f}")
  
  def market_open(context):
      """开盘后执行"""
      # 获取历史数据
      bars = get_bars(context.symbol, context.slow_period + 5, '1d')
      if bars is None or len(bars) < context.slow_period:
          return
      
      # 计算均线
      close = bars['close']
      fast_ma = close.rolling(context.fast_period).mean().iloc[-1]
      slow_ma = close.rolling(context.slow_period).mean().iloc[-1]
      current_price = close.iloc[-1]
      
      # 获取持仓
      position = get_position(context.symbol)
      
      # 交易逻辑
      if fast_ma > slow_ma:
          if position is None or position.volume == 0:
              available = context.portfolio.available_cash * context.position_ratio
              volume = int(available / current_price / 100) * 100
              if volume >= 100:
                  order(context.symbol, volume)
                  context.traded_today = True
                  log.info(f"买入 {context.symbol}, 数量: {volume}")
      
      elif fast_ma < slow_ma:
          if position and position.volume > 0:
              order(context.symbol, -position.volume)
              log.info(f"卖出 {context.symbol}, 数量: {position.volume}")
  
  def check_risk(context):
      """风控检查"""
      current_value = context.portfolio.total_value
      
      # 更新高水位
      if current_value > context.high_water_mark:
          context.high_water_mark = current_value
      
      # 计算回撤
      drawdown = (current_value - context.high_water_mark) / context.high_water_mark
      
      # 计算当日亏损
      daily_pnl = (current_value - context.daily_start_value) / context.daily_start_value
      
      log.info(f"风控检查 - 回撤: {drawdown:.2%}, 当日盈亏: {daily_pnl:.2%}")
      
      # 触发风控
      if drawdown < -context.max_drawdown:
          log.warn(f"触发回撤风控: {drawdown:.2%}")
          close_all_positions(context)
      
      if daily_pnl < -context.daily_loss_limit:
          log.warn(f"触发日亏损风控: {daily_pnl:.2%}")
          close_all_positions(context)
  
  def market_close(context):
      """收盘处理"""
      log.info(f"收盘净值: {context.portfolio.total_value:.2f}")
  
  def close_all_positions(context):
      """平掉所有仓位"""
      for position in get_positions():
          if position.volume > 0:
              order(position.symbol, -position.volume)
              log.info(f"风控平仓: {position.symbol}")
  
  def on_order(context, order):
      """订单回调"""
      if order.status == 'filled':
          log.info(f"订单成交: {order.symbol}, {order.side}, "
                  f"{order.filled_volume}@{order.filled_price}")
  ```

### Day 54-56：模拟交易验证

- [ ] **TODO-P2-11.1** 模拟交易检查清单
  ```markdown
  ## 模拟交易验证清单
  
  ### 功能验证
  - [ ] 策略正常启动
  - [ ] 行情数据接收正常
  - [ ] 订单正常发送
  - [ ] 成交回报正常
  - [ ] 持仓更新正常
  - [ ] 风控规则触发正常
  
  ### 数据验证
  - [ ] K线数据完整
  - [ ] 技术指标计算正确
  - [ ] 信号生成时机正确
  
  ### 风控验证
  - [ ] 单笔亏损限制
  - [ ] 日亏损限制
  - [ ] 回撤限制
  - [ ] 仓位限制
  
  ### 性能验证
  - [ ] 订单延迟
  - [ ] 策略计算时间
  - [ ] 内存占用
  ```

- [ ] **TODO-P2-11.2** 交易日志分析脚本
  ```python
  # 文件：~/quant_trading/analysis/trade_log_analyzer.py
  """
  交易日志分析
  """
  import pandas as pd
  import matplotlib.pyplot as plt
  from datetime import datetime
  
  class TradeLogAnalyzer:
      """交易日志分析器"""
      
      def __init__(self, log_file: str):
          self.trades = self.parse_log(log_file)
      
      def parse_log(self, log_file: str) -> pd.DataFrame:
          """解析交易日志"""
          # 实际实现根据日志格式
          trades = []
          # 解析逻辑...
          return pd.DataFrame(trades)
      
      def calculate_metrics(self) -> dict:
          """计算交易指标"""
          if len(self.trades) == 0:
              return {}
          
          # 胜率
          wins = self.trades[self.trades['pnl'] > 0]
          win_rate = len(wins) / len(self.trades)
          
          # 盈亏比
          avg_win = wins['pnl'].mean() if len(wins) > 0 else 0
          losses = self.trades[self.trades['pnl'] < 0]
          avg_loss = abs(losses['pnl'].mean()) if len(losses) > 0 else 0
          profit_loss_ratio = avg_win / avg_loss if avg_loss > 0 else 0
          
          # 平均持仓时间
          avg_holding = self.trades['holding_time'].mean()
          
          return {
              'total_trades': len(self.trades),
              'win_rate': win_rate,
              'profit_loss_ratio': profit_loss_ratio,
              'avg_holding_time': avg_holding,
              'total_pnl': self.trades['pnl'].sum()
          }
      
      def plot_equity_curve(self):
          """绘制资金曲线"""
          cum_pnl = self.trades['pnl'].cumsum()
          
          plt.figure(figsize=(12, 6))
          plt.plot(cum_pnl.values)
          plt.title('累计盈亏曲线')
          plt.xlabel('交易次数')
          plt.ylabel('累计盈亏')
          plt.grid(True)
          plt.show()
  ```

#### 第九周完成检查点
- [ ] QMT环境配置成功
- [ ] 策略迁移到QMT
- [ ] 模拟交易运行3天以上
- [ ] 交易日志分析完成
- [ ] 策略偏离回测<5%

---

## 第十周：Go语言量化模块

### Day 57-59：Go量化基础

- [ ] **TODO-P2-12.1** Go量化项目初始化
  ```bash
  mkdir -p ~/quant_go
  cd ~/quant_go
  go mod init quant_trading
  
  # 安装常用库
  go get github.com/markcheno/go-talib
  go get github.com/shopspring/decimal
  go get github.com/gorilla/websocket
  go get github.com/nats-io/nats.go
  ```

- [ ] **TODO-P2-12.2** 实现高性能技术指标计算
  ```go
  // 文件：~/quant_go/indicators/indicators.go
  package indicators
  
  import (
      "math"
  )
  
  // SMA 简单移动平均
  func SMA(data []float64, period int) []float64 {
      if len(data) < period {
          return nil
      }
      
      result := make([]float64, len(data))
      
      // 计算第一个SMA
      sum := 0.0
      for i := 0; i < period; i++ {
          sum += data[i]
      }
      result[period-1] = sum / float64(period)
      
      // 滚动计算
      for i := period; i < len(data); i++ {
          sum = sum - data[i-period] + data[i]
          result[i] = sum / float64(period)
      }
      
      return result
  }
  
  // EMA 指数移动平均
  func EMA(data []float64, period int) []float64 {
      if len(data) < period {
          return nil
      }
      
      result := make([]float64, len(data))
      multiplier := 2.0 / float64(period+1)
      
      // 第一个EMA使用SMA
      sum := 0.0
      for i := 0; i < period; i++ {
          sum += data[i]
      }
      result[period-1] = sum / float64(period)
      
      // 后续EMA
      for i := period; i < len(data); i++ {
          result[i] = (data[i]-result[i-1])*multiplier + result[i-1]
      }
      
      return result
  }
  
  // RSI 相对强弱指数
  func RSI(data []float64, period int) []float64 {
      if len(data) < period+1 {
          return nil
      }
      
      result := make([]float64, len(data))
      gains := make([]float64, len(data))
      losses := make([]float64, len(data))
      
      // 计算涨跌
      for i := 1; i < len(data); i++ {
          change := data[i] - data[i-1]
          if change > 0 {
              gains[i] = change
          } else {
              losses[i] = -change
          }
      }
      
      // 计算平均涨跌
      avgGain := 0.0
      avgLoss := 0.0
      for i := 1; i <= period; i++ {
          avgGain += gains[i]
          avgLoss += losses[i]
      }
      avgGain /= float64(period)
      avgLoss /= float64(period)
      
      if avgLoss == 0 {
          result[period] = 100
      } else {
          rs := avgGain / avgLoss
          result[period] = 100 - 100/(1+rs)
      }
      
      // 后续RSI
      for i := period + 1; i < len(data); i++ {
          avgGain = (avgGain*float64(period-1) + gains[i]) / float64(period)
          avgLoss = (avgLoss*float64(period-1) + losses[i]) / float64(period)
          
          if avgLoss == 0 {
              result[i] = 100
          } else {
              rs := avgGain / avgLoss
              result[i] = 100 - 100/(1+rs)
          }
      }
      
      return result
  }
  
  // ATR 平均真实波幅
  func ATR(high, low, close []float64, period int) []float64 {
      if len(high) < period+1 {
          return nil
      }
      
      n := len(high)
      tr := make([]float64, n)
      result := make([]float64, n)
      
      // 计算True Range
      tr[0] = high[0] - low[0]
      for i := 1; i < n; i++ {
          hl := high[i] - low[i]
          hc := math.Abs(high[i] - close[i-1])
          lc := math.Abs(low[i] - close[i-1])
          tr[i] = math.Max(hl, math.Max(hc, lc))
      }
      
      // 计算ATR（使用EMA）
      atr := EMA(tr, period)
      copy(result, atr)
      
      return result
  }
  ```

- [ ] **TODO-P2-12.3** 实现订单管理器
  ```go
  // 文件：~/quant_go/order/manager.go
  package order
  
  import (
      "sync"
      "time"
  )
  
  type OrderSide string
  type OrderStatus string
  
  const (
      Buy  OrderSide = "BUY"
      Sell OrderSide = "SELL"
      
      Pending   OrderStatus = "PENDING"
      Submitted OrderStatus = "SUBMITTED"
      Filled    OrderStatus = "FILLED"
      Cancelled OrderStatus = "CANCELLED"
      Rejected  OrderStatus = "REJECTED"
  )
  
  type Order struct {
      ID          string
      Symbol      string
      Side        OrderSide
      Price       float64
      Volume      int64
      FilledVol   int64
      FilledPrice float64
      Status      OrderStatus
      CreateTime  time.Time
      UpdateTime  time.Time
  }
  
  type OrderManager struct {
      orders    map[string]*Order
      mutex     sync.RWMutex
      orderChan chan *Order
  }
  
  func NewOrderManager() *OrderManager {
      return &OrderManager{
          orders:    make(map[string]*Order),
          orderChan: make(chan *Order, 1000),
      }
  }
  
  func (m *OrderManager) CreateOrder(symbol string, side OrderSide, 
                                      price float64, volume int64) *Order {
      m.mutex.Lock()
      defer m.mutex.Unlock()
      
      order := &Order{
          ID:         generateOrderID(),
          Symbol:     symbol,
          Side:       side,
          Price:      price,
          Volume:     volume,
          Status:     Pending,
          CreateTime: time.Now(),
          UpdateTime: time.Now(),
      }
      
      m.orders[order.ID] = order
      return order
  }
  
  func (m *OrderManager) UpdateOrder(orderID string, status OrderStatus,
                                      filledVol int64, filledPrice float64) {
      m.mutex.Lock()
      defer m.mutex.Unlock()
      
      if order, ok := m.orders[orderID]; ok {
          order.Status = status
          order.FilledVol = filledVol
          order.FilledPrice = filledPrice
          order.UpdateTime = time.Now()
          
          // 发送到通道
          m.orderChan <- order
      }
  }
  
  func (m *OrderManager) GetOrder(orderID string) *Order {
      m.mutex.RLock()
      defer m.mutex.RUnlock()
      return m.orders[orderID]
  }
  
  func (m *OrderManager) GetOrderChannel() <-chan *Order {
      return m.orderChan
  }
  
  func generateOrderID() string {
      return time.Now().Format("20060102150405.000000")
  }
  ```

### Day 60-61：Python-Go协作

- [ ] **TODO-P2-13.1** 实现gRPC通信接口
  ```protobuf
  // 文件：~/quant_go/proto/trading.proto
  syntax = "proto3";
  
  package trading;
  option go_package = "./pb";
  
  service TradingService {
      rpc CalculateIndicators(IndicatorRequest) returns (IndicatorResponse);
      rpc SendOrder(OrderRequest) returns (OrderResponse);
      rpc GetPosition(PositionRequest) returns (PositionResponse);
  }
  
  message IndicatorRequest {
      string indicator_name = 1;
      repeated double data = 2;
      int32 period = 3;
  }
  
  message IndicatorResponse {
      repeated double result = 1;
      string error = 2;
  }
  
  message OrderRequest {
      string symbol = 1;
      string side = 2;
      double price = 3;
      int64 volume = 4;
  }
  
  message OrderResponse {
      string order_id = 1;
      string status = 2;
      string error = 3;
  }
  
  message PositionRequest {
      string symbol = 1;
  }
  
  message PositionResponse {
      string symbol = 1;
      int64 volume = 2;
      double avg_price = 3;
      double pnl = 4;
  }
  ```

- [ ] **TODO-P2-13.2** 实现Go gRPC服务端
  ```go
  // 文件：~/quant_go/server/main.go
  package main
  
  import (
      "context"
      "log"
      "net"
      
      "google.golang.org/grpc"
      pb "quant_trading/pb"
      "quant_trading/indicators"
  )
  
  type server struct {
      pb.UnimplementedTradingServiceServer
  }
  
  func (s *server) CalculateIndicators(ctx context.Context, 
                                        req *pb.IndicatorRequest) (*pb.IndicatorResponse, error) {
      var result []float64
      
      switch req.IndicatorName {
      case "SMA":
          result = indicators.SMA(req.Data, int(req.Period))
      case "EMA":
          result = indicators.EMA(req.Data, int(req.Period))
      case "RSI":
          result = indicators.RSI(req.Data, int(req.Period))
      default:
          return &pb.IndicatorResponse{Error: "Unknown indicator"}, nil
      }
      
      return &pb.IndicatorResponse{Result: result}, nil
  }
  
  func main() {
      lis, err := net.Listen("tcp", ":50051")
      if err != nil {
          log.Fatalf("failed to listen: %v", err)
      }
      
      s := grpc.NewServer()
      pb.RegisterTradingServiceServer(s, &server{})
      
      log.Println("gRPC server listening on :50051")
      if err := s.Serve(lis); err != nil {
          log.Fatalf("failed to serve: %v", err)
      }
  }
  ```

- [ ] **TODO-P2-13.3** Python客户端调用
  ```python
  # 文件：~/quant_trading/grpc_client/trading_client.py
  """
  Python gRPC客户端
  """
  import grpc
  import trading_pb2
  import trading_pb2_grpc
  import numpy as np
  
  class TradingClient:
      """交易服务客户端"""
      
      def __init__(self, host: str = 'localhost', port: int = 50051):
          self.channel = grpc.insecure_channel(f'{host}:{port}')
          self.stub = trading_pb2_grpc.TradingServiceStub(self.channel)
      
      def calculate_sma(self, data: np.ndarray, period: int) -> np.ndarray:
          """计算SMA（通过Go服务）"""
          request = trading_pb2.IndicatorRequest(
              indicator_name='SMA',
              data=data.tolist(),
              period=period
          )
          response = self.stub.CalculateIndicators(request)
          
          if response.error:
              raise Exception(response.error)
          
          return np.array(response.result)
      
      def calculate_rsi(self, data: np.ndarray, period: int) -> np.ndarray:
          """计算RSI（通过Go服务）"""
          request = trading_pb2.IndicatorRequest(
              indicator_name='RSI',
              data=data.tolist(),
              period=period
          )
          response = self.stub.CalculateIndicators(request)
          
          if response.error:
              raise Exception(response.error)
          
          return np.array(response.result)
  
  # 性能对比测试
  if __name__ == "__main__":
      import time
      import pandas_ta as ta
      
      # 生成测试数据
      data = np.random.randn(10000).cumsum() + 100
      
      client = TradingClient()
      
      # Go计算
      start = time.time()
      for _ in range(100):
          go_result = client.calculate_sma(data, 20)
      go_time = time.time() - start
      
      # Python计算
      import pandas as pd
      series = pd.Series(data)
      start = time.time()
      for _ in range(100):
          py_result = series.rolling(20).mean().values
      py_time = time.time() - start
      
      print(f"Go计算时间: {go_time:.3f}s")
      print(f"Python计算时间: {py_time:.3f}s")
      print(f"加速比: {py_time/go_time:.2f}x")
  ```

### Day 62-63：第二阶段总结

- [ ] **TODO-P2-14.1** 完成第二阶段技能自查
  ```markdown
  ## 第二阶段技能自查清单
  
  ### vnpy框架
  - [ ] 理解事件驱动架构
  - [ ] CTA策略模板熟练使用
  - [ ] ArrayManager指标计算
  - [ ] 本地回测和参数优化
  - [ ] 多品种策略开发
  
  ### 多因子模型
  - [ ] 因子合成方法（等权、IC加权、机器学习）
  - [ ] 因子正交化处理
  - [ ] LightGBM选股模型
  - [ ] 滚动训练框架
  
  ### 风险管理
  - [ ] 多层次风控规则
  - [ ] 仓位管理方法（风险平价、凯利公式）
  - [ ] 风控与策略集成
  
  ### QMT实战
  - [ ] 环境配置成功
  - [ ] 策略迁移完成
  - [ ] 模拟交易运行
  
  ### Go语言模块
  - [ ] 高性能指标计算
  - [ ] 订单管理器
  - [ ] gRPC通信
  ```

- [ ] **TODO-P2-14.2** 整理第二阶段代码
  ```bash
  # 第二阶段项目结构
  ~/quant_trading/
  ├── vnpy_strategies/      # vnpy策略
  │   ├── boll_cci_strategy.py
  │   ├── spread_strategy.py
  │   ├── intraday_strategy.py
  │   └── risk_controlled_strategy.py
  ├── vnpy_backtest/        # vnpy回测
  │   ├── run_cta_backtest.py
  │   └── optimize_strategy.py
  ├── database/             # 数据库
  │   ├── timescale_manager.py
  │   └── batch_import.py
  ├── factors/              # 因子模块
  │   ├── factor_combiner.py
  │   └── factor_orthogonalize.py
  ├── models/               # 机器学习模型
  │   ├── lgbm_selector.py
  │   └── rolling_trainer.py
  ├── risk/                 # 风控模块
  │   ├── risk_manager.py
  │   └── position_manager.py
  ├── qmt_strategies/       # QMT策略
  │   └── dual_ma_strategy.py
  └── analysis/             # 分析模块
      └── trade_log_analyzer.py
  
  ~/quant_go/               # Go模块
  ├── indicators/
  ├── order/
  ├── proto/
  ├── pb/
  └── server/
  ```

#### 第十周完成检查点
- [ ] Go量化模块完成
- [ ] gRPC通信测试通过
- [ ] Python-Go协作验证
- [ ] 第二阶段代码整理完成

---

## 第三阶段预告（第4-6个月）

完成第二阶段后，第三阶段将重点：

1. **实盘交易准备**
   - A股QMT实盘
   - 港股富途OpenAPI
   - 加密货币交易

2. **系统架构优化**
   - 微服务架构
   - 消息队列集成
   - 监控告警系统

3. **高级策略研究**
   - 统计套利
   - 机器学习策略
   - 强化学习入门

4. **全链路系统**
   - 数据采集
   - 策略研究
   - 实盘执行
   - 监控运维

---

## Claude Code使用提示

```
"请帮我完成TODO-P2-1.2，验证vnpy安装"
"请帮我实现TODO-P2-6.1的因子合成方法"
"请解释vnpy的事件驱动架构原理"
"请帮我调试LightGBM选股模型的报错"
```

---

**文档版本**：v1.0
**创建日期**：2024年12月
**适用阶段**：量化交易学习第二阶段（第2-3个月）