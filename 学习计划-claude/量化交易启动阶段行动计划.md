# é‡åŒ–äº¤æ˜“å¯åŠ¨é˜¶æ®µè¡ŒåŠ¨è®¡åˆ’ï¼ˆ1-2ä¸ªæœˆï¼‰

> **ç›®æ ‡**ï¼šå®ŒæˆPythoné‡åŒ–ç¼–ç¨‹èƒ½åŠ›å»ºè®¾ + ç¬¬ä¸€ä¸ªå¯å›æµ‹ç­–ç•¥ + æœ¬åœ°å¼€å‘ç¯å¢ƒæ­å»º
> **é¢„æœŸäº§å‡º**ï¼š3ä¸ªå¯è¿è¡Œçš„å›æµ‹ç­–ç•¥ + 1å¥—å®Œæ•´çš„æœ¬åœ°é‡åŒ–å¼€å‘ç¯å¢ƒ

---

## ç¬¬ä¸€å‘¨ï¼šç¯å¢ƒæ­å»º + Pythoné‡‘èç¼–ç¨‹é€Ÿæˆ

ä½œä¸ºèµ„æ·±ç¨‹åºå‘˜ï¼Œæ‚¨å¯ä»¥å¿«é€Ÿå®Œæˆç¯å¢ƒé…ç½®ï¼Œé‡ç‚¹æ”¾åœ¨Pythoné‡‘èåº“çš„ç†Ÿæ‚‰ä¸Šã€‚

### Day 1-2ï¼šå¼€å‘ç¯å¢ƒæ­å»º

**æœ¬åœ°ç¯å¢ƒé…ç½®æ¸…å•**ï¼š

```bash
# 1. Pythonç¯å¢ƒï¼ˆæ¨è3.11ï¼Œå…¼å®¹æ€§æœ€ä½³ï¼‰
# ä½¿ç”¨condaç®¡ç†ç¯å¢ƒ
conda create -n quant python=3.11
conda activate quant

# 2. æ ¸å¿ƒé‡åŒ–åº“
pip install numpy pandas matplotlib seaborn jupyter

# 3. é‡‘èæ•°æ®åº“
pip install tushare akshare yfinance

# 4. å›æµ‹æ¡†æ¶ï¼ˆå…ˆè£…è½»é‡çº§çš„ï¼‰
pip install backtesting  # Backtesting.pyï¼Œå…¥é—¨æœ€ç®€å•
pip install backtrader2  # ç¤¾åŒºç»´æŠ¤ç‰ˆï¼ŒåŠŸèƒ½æ›´å…¨

# 5. æŠ€æœ¯æŒ‡æ ‡åº“
pip install pandas-ta    # çº¯Pythonï¼Œ150+æŒ‡æ ‡
pip install ta           # å¦ä¸€ä¸ªçº¯Pythoné€‰æ‹©

# 6. å¯è§†åŒ–å¢å¼º
pip install plotly mplfinance

# 7. æ•°æ®å­˜å‚¨
pip install sqlalchemy   # ORM
pip install redis        # ç¼“å­˜ï¼ˆæ‚¨åº”è¯¥ç†Ÿæ‚‰ï¼‰
```

**Tushare Pro æ³¨å†Œä¸é…ç½®**ï¼š
1. è®¿é—® https://tushare.pro æ³¨å†Œè´¦å·
2. è·å–API Tokenï¼ˆä¸ªäººä¸­å¿ƒ â†’ æ¥å£TOKENï¼‰
3. æ–°ç”¨æˆ·è·å¾—100ç§¯åˆ†ï¼Œå®Œæˆä»¥ä¸‹å¯å¿«é€Ÿæå‡ï¼š
   - ç»‘å®šæ‰‹æœºï¼š+50åˆ†
   - å®Œå–„ä¸ªäººä¿¡æ¯ï¼š+20åˆ†
   - é‚€è¯·å¥½å‹ï¼šæ¯äºº+10åˆ†
   - å­¦ç”Ÿè®¤è¯ï¼ˆå¦‚é€‚ç”¨ï¼‰ï¼šå¯ç”³è¯·é«˜çº§æ¥å£

```python
# éªŒè¯Tushareé…ç½®
import tushare as ts
ts.set_token('your_token_here')
pro = ts.pro_api()

# æµ‹è¯•è·å–æ•°æ®
df = pro.daily(ts_code='000001.SZ', start_date='20240101', end_date='20240601')
print(df.head())
```

**AKShare é…ç½®ï¼ˆæ— éœ€æ³¨å†Œï¼Œå¤‡ç”¨æ•°æ®æºï¼‰**ï¼š

```python
import akshare as ak

# è·å–Aè‚¡æ—¥çº¿æ•°æ®
df = ak.stock_zh_a_hist(symbol="000001", period="daily", 
                        start_date="20240101", end_date="20240601")
print(df.head())

# è·å–æ¸¯è‚¡æ•°æ®
df_hk = ak.stock_hk_hist(symbol="00700", period="daily",
                         start_date="20240101", end_date="20240601")
print(df_hk.head())
```

**IDEé…ç½®å»ºè®®**ï¼š
- ä¸»åŠ›IDEï¼šVS Code + Python/Jupyteræ‰©å±•ï¼ˆæ‚¨åº”è¯¥å¾ˆç†Ÿæ‚‰ï¼‰
- æ•°æ®æ¢ç´¢ï¼šJupyterLabï¼ˆäº¤äº’å¼åˆ†æï¼‰
- ç‰ˆæœ¬ç®¡ç†ï¼šGitï¼ˆé‡åŒ–ä»£ç åŠ¡å¿…ç‰ˆæœ¬æ§åˆ¶ï¼‰

### Day 3-5ï¼šPythoné‡‘èç¼–ç¨‹æ ¸å¿ƒ

**æ‚¨éœ€è¦é‡ç‚¹æŒæ¡çš„Pythonåº“**ï¼ˆå‡è®¾æ‚¨å·²æœ‰åŸºç¡€PythonçŸ¥è¯†ï¼‰ï¼š

**Pandasé‡‘èæ•°æ®å¤„ç†**ï¼ˆæœ€é‡è¦ï¼Œæ¯å¤©éƒ½ä¼šç”¨ï¼‰ï¼š

```python
import pandas as pd
import numpy as np

# 1. æ—¶é—´åºåˆ—ç´¢å¼•ï¼ˆé‡åŒ–æ ¸å¿ƒï¼‰
df['trade_date'] = pd.to_datetime(df['trade_date'])
df.set_index('trade_date', inplace=True)
df.sort_index(inplace=True)

# 2. æ”¶ç›Šç‡è®¡ç®—
df['return'] = df['close'].pct_change()           # ç®€å•æ”¶ç›Šç‡
df['log_return'] = np.log(df['close'] / df['close'].shift(1))  # å¯¹æ•°æ”¶ç›Šç‡

# 3. æ»šåŠ¨çª—å£è®¡ç®—ï¼ˆå› å­è®¡ç®—åŸºç¡€ï¼‰
df['ma20'] = df['close'].rolling(window=20).mean()
df['volatility'] = df['return'].rolling(window=20).std() * np.sqrt(252)

# 4. åˆ†ç»„æ“ä½œï¼ˆå¤šè‚¡ç¥¨å¤„ç†ï¼‰
grouped = df.groupby('ts_code')
df['rank'] = grouped['return'].rank(pct=True)

# 5. é‡é‡‡æ ·ï¼ˆæ—¥çº¿â†’å‘¨çº¿/æœˆçº¿ï¼‰
weekly = df.resample('W').agg({
    'open': 'first',
    'high': 'max',
    'low': 'min',
    'close': 'last',
    'vol': 'sum'
})
```

**NumPyå‘é‡åŒ–è®¡ç®—**ï¼š

```python
import numpy as np

# å‘é‡åŒ–æ˜¯æ€§èƒ½å…³é”®ï¼Œé¿å…Pythonå¾ªç¯
prices = df['close'].values

# å¸ƒæ—å¸¦è®¡ç®—ï¼ˆå‘é‡åŒ–ï¼‰
window = 20
ma = np.convolve(prices, np.ones(window)/window, mode='valid')
std = pd.Series(prices).rolling(window).std().dropna().values
upper = ma + 2 * std
lower = ma - 2 * std

# ä¿¡å·ç”Ÿæˆï¼ˆå‘é‡åŒ–ï¼‰
signals = np.where(prices[window-1:] > upper, -1,  # è¶…ä¹°å–å‡º
          np.where(prices[window-1:] < lower, 1,   # è¶…å–ä¹°å…¥
          0))
```

### Day 6-7ï¼šç¬¬ä¸€ä¸ªç­–ç•¥å›æµ‹

**ä½¿ç”¨Backtesting.pyå®ç°åŒå‡çº¿ç­–ç•¥**ï¼ˆæœ€ç®€å•çš„å…¥é—¨ï¼‰ï¼š

```python
from backtesting import Backtest, Strategy
from backtesting.lib import crossover
import pandas as pd

# å‡†å¤‡æ•°æ®ï¼ˆOHLCVæ ¼å¼ï¼Œåˆ—åå¿…é¡»æ˜¯Open/High/Low/Close/Volumeï¼‰
def prepare_data(df):
    """å°†tushareæ•°æ®è½¬æ¢ä¸ºbacktestingæ ¼å¼"""
    data = df.copy()
    data.columns = [c.capitalize() for c in data.columns]
    data.index = pd.to_datetime(data.index)
    return data[['Open', 'High', 'Low', 'Close', 'Volume']]

class SmaCross(Strategy):
    # å‚æ•°å®šä¹‰ï¼ˆå¯ä¼˜åŒ–ï¼‰
    n1 = 10  # çŸ­æœŸå‡çº¿
    n2 = 30  # é•¿æœŸå‡çº¿
    
    def init(self):
        # è®¡ç®—æŒ‡æ ‡
        close = self.data.Close
        self.sma1 = self.I(lambda x: pd.Series(x).rolling(self.n1).mean(), close)
        self.sma2 = self.I(lambda x: pd.Series(x).rolling(self.n2).mean(), close)
    
    def next(self):
        # äº¤æ˜“é€»è¾‘
        if crossover(self.sma1, self.sma2):
            self.buy()
        elif crossover(self.sma2, self.sma1):
            self.sell()

# è¿è¡Œå›æµ‹
bt = Backtest(data, SmaCross, cash=100000, commission=0.001)
stats = bt.run()
print(stats)

# å¯è§†åŒ–
bt.plot()

# å‚æ•°ä¼˜åŒ–
stats_opt = bt.optimize(
    n1=range(5, 30, 5),
    n2=range(20, 60, 5),
    maximize='Sharpe Ratio',
    constraint=lambda p: p.n1 < p.n2  # çŸ­æœŸ<é•¿æœŸ
)
```

**æœ¬å‘¨äº§å‡ºæ£€æŸ¥æ¸…å•**ï¼š
- [ ] Pythoné‡åŒ–ç¯å¢ƒå¯æ­£å¸¸è¿è¡Œ
- [ ] Tushare/AKShareå¯è·å–Aè‚¡æ•°æ®
- [ ] å®ŒæˆåŒå‡çº¿ç­–ç•¥å›æµ‹å¹¶ç†è§£æ¯è¡Œä»£ç 
- [ ] èƒ½å¤Ÿä¿®æ”¹å‚æ•°å¹¶è§‚å¯Ÿç»“æœå˜åŒ–

---

## ç¬¬äºŒå‘¨ï¼šæŠ€æœ¯æŒ‡æ ‡ + ç­–ç•¥ç±»å‹æ·±å…¥

### Day 8-10ï¼šæŠ€æœ¯æŒ‡æ ‡ä½“ç³»

**å¸¸ç”¨æŠ€æœ¯æŒ‡æ ‡åˆ†ç±»ä¸å®ç°**ï¼š

```python
import pandas_ta as ta

# ä¸ºDataFrameæ·»åŠ æ‰€æœ‰å¸¸ç”¨æŒ‡æ ‡
df.ta.strategy("all")  # æ·»åŠ å…¨éƒ¨æŒ‡æ ‡ï¼ˆæ…¢ï¼Œç”¨äºå­¦ä¹ ï¼‰

# æˆ–è€…é€‰æ‹©æ€§æ·»åŠ 
# 1. è¶‹åŠ¿æŒ‡æ ‡
df['sma_20'] = ta.sma(df['close'], length=20)
df['ema_20'] = ta.ema(df['close'], length=20)
df['macd'] = ta.macd(df['close'])['MACD_12_26_9']

# 2. åŠ¨é‡æŒ‡æ ‡
df['rsi'] = ta.rsi(df['close'], length=14)
df['stoch_k'] = ta.stoch(df['high'], df['low'], df['close'])['STOCHk_14_3_3']

# 3. æ³¢åŠ¨ç‡æŒ‡æ ‡
bbands = ta.bbands(df['close'], length=20, std=2)
df['bb_upper'] = bbands['BBU_20_2.0']
df['bb_lower'] = bbands['BBL_20_2.0']
df['atr'] = ta.atr(df['high'], df['low'], df['close'], length=14)

# 4. æˆäº¤é‡æŒ‡æ ‡
df['obv'] = ta.obv(df['close'], df['volume'])
df['vwap'] = ta.vwap(df['high'], df['low'], df['close'], df['volume'])
```

**æŒ‡æ ‡ç»„åˆç­–ç•¥ç¤ºä¾‹ï¼ˆRSI + MACDï¼‰**ï¼š

```python
class RsiMacd(Strategy):
    rsi_period = 14
    rsi_oversold = 30
    rsi_overbought = 70
    
    def init(self):
        close = pd.Series(self.data.Close)
        
        # RSI
        self.rsi = self.I(ta.rsi, close, length=self.rsi_period)
        
        # MACD
        macd_result = ta.macd(close)
        self.macd = self.I(lambda: macd_result['MACD_12_26_9'].values)
        self.signal = self.I(lambda: macd_result['MACDs_12_26_9'].values)
    
    def next(self):
        # ä¹°å…¥æ¡ä»¶ï¼šRSIè¶…å– + MACDé‡‘å‰
        if (self.rsi[-1] < self.rsi_oversold and 
            self.macd[-1] > self.signal[-1] and 
            self.macd[-2] <= self.signal[-2]):
            self.buy()
        
        # å–å‡ºæ¡ä»¶ï¼šRSIè¶…ä¹° æˆ– MACDæ­»å‰
        elif (self.rsi[-1] > self.rsi_overbought or
              (self.macd[-1] < self.signal[-1] and 
               self.macd[-2] >= self.signal[-2])):
            self.position.close()
```

### Day 11-12ï¼šç†è§£ç­–ç•¥ç±»å‹

**è¶‹åŠ¿è·Ÿè¸ªç­–ç•¥**ï¼ˆé€‚åˆå•è¾¹è¡Œæƒ…ï¼‰ï¼š

```python
class TrendFollowing(Strategy):
    """æµ·é¾Ÿäº¤æ˜“æ³•åˆ™ç®€åŒ–ç‰ˆ"""
    entry_window = 20   # çªç ´å‘¨æœŸ
    exit_window = 10    # é€€å‡ºå‘¨æœŸ
    atr_period = 20
    risk_ratio = 0.02   # å•ç¬”é£é™©2%
    
    def init(self):
        high = pd.Series(self.data.High)
        low = pd.Series(self.data.Low)
        close = pd.Series(self.data.Close)
        
        self.entry_high = self.I(lambda: high.rolling(self.entry_window).max().values)
        self.entry_low = self.I(lambda: low.rolling(self.entry_window).min().values)
        self.exit_high = self.I(lambda: high.rolling(self.exit_window).max().values)
        self.exit_low = self.I(lambda: low.rolling(self.exit_window).min().values)
        self.atr = self.I(ta.atr, high, low, close, length=self.atr_period)
    
    def next(self):
        price = self.data.Close[-1]
        
        if not self.position:
            # çªç ´æœ€é«˜ç‚¹åšå¤š
            if price > self.entry_high[-2]:
                # åŸºäºATRè®¡ç®—ä»“ä½
                risk_amount = self.equity * self.risk_ratio
                stop_distance = 2 * self.atr[-1]
                size = risk_amount / stop_distance
                self.buy(size=size, sl=price - stop_distance)
        else:
            # è·Œç ´é€€å‡ºä½ç‚¹å¹³ä»“
            if price < self.exit_low[-2]:
                self.position.close()
```

**å‡å€¼å›å½’ç­–ç•¥**ï¼ˆé€‚åˆéœ‡è¡è¡Œæƒ…ï¼‰ï¼š

```python
class MeanReversion(Strategy):
    """å¸ƒæ—å¸¦å‡å€¼å›å½’"""
    bb_period = 20
    bb_std = 2
    
    def init(self):
        close = pd.Series(self.data.Close)
        bbands = ta.bbands(close, length=self.bb_period, std=self.bb_std)
        
        self.bb_upper = self.I(lambda: bbands['BBU_20_2.0'].values)
        self.bb_lower = self.I(lambda: bbands['BBL_20_2.0'].values)
        self.bb_mid = self.I(lambda: bbands['BBM_20_2.0'].values)
    
    def next(self):
        price = self.data.Close[-1]
        
        if not self.position:
            # è§¦åŠä¸‹è½¨ä¹°å…¥
            if price < self.bb_lower[-1]:
                self.buy(sl=self.bb_lower[-1] * 0.98,  # æ­¢æŸ
                        tp=self.bb_mid[-1])            # æ­¢ç›ˆåˆ°ä¸­è½¨
            # è§¦åŠä¸Šè½¨åšç©ºï¼ˆå¦‚æœæ”¯æŒï¼‰
            elif price > self.bb_upper[-1]:
                self.sell(sl=self.bb_upper[-1] * 1.02,
                         tp=self.bb_mid[-1])
```

### Day 13-14ï¼šå¤šè‚¡ç¥¨å›æµ‹æ¡†æ¶

**ä»å•è‚¡ç¥¨æ‰©å±•åˆ°è‚¡ç¥¨æ± **ï¼š

```python
import pandas as pd
import numpy as np
from concurrent.futures import ProcessPoolExecutor
from backtesting import Backtest

def backtest_single_stock(args):
    """å•åªè‚¡ç¥¨å›æµ‹"""
    ts_code, data, strategy_class = args
    try:
        bt = Backtest(data, strategy_class, cash=100000, commission=0.001)
        stats = bt.run()
        return {
            'ts_code': ts_code,
            'return': stats['Return [%]'],
            'sharpe': stats['Sharpe Ratio'],
            'max_drawdown': stats['Max. Drawdown [%]'],
            'trades': stats['# Trades']
        }
    except Exception as e:
        return {'ts_code': ts_code, 'error': str(e)}

def backtest_portfolio(stock_list, strategy_class, start_date, end_date):
    """è‚¡ç¥¨æ± å¹¶è¡Œå›æµ‹"""
    # è·å–æ‰€æœ‰è‚¡ç¥¨æ•°æ®
    all_data = {}
    for ts_code in stock_list:
        df = pro.daily(ts_code=ts_code, start_date=start_date, end_date=end_date)
        if len(df) > 100:  # è‡³å°‘100ä¸ªäº¤æ˜“æ—¥
            all_data[ts_code] = prepare_data(df)
    
    # å¹¶è¡Œå›æµ‹
    args_list = [(code, data, strategy_class) for code, data in all_data.items()]
    
    with ProcessPoolExecutor(max_workers=4) as executor:
        results = list(executor.map(backtest_single_stock, args_list))
    
    return pd.DataFrame(results)

# ç¤ºä¾‹ï¼šæ²ªæ·±300æˆåˆ†è‚¡å›æµ‹
hs300 = pro.index_weight(index_code='399300.SZ')
stock_list = hs300['con_code'].unique()[:50]  # å…ˆæµ‹è¯•50åª

results = backtest_portfolio(stock_list, SmaCross, '20220101', '20241201')
print(results.sort_values('sharpe', ascending=False).head(20))
```

**æœ¬å‘¨äº§å‡ºæ£€æŸ¥æ¸…å•**ï¼š
- [ ] ç†Ÿç»ƒä½¿ç”¨pandas-taè®¡ç®—å„ç±»æŠ€æœ¯æŒ‡æ ‡
- [ ] å®Œæˆè¶‹åŠ¿è·Ÿè¸ªç­–ç•¥ï¼ˆçªç ´ç±»ï¼‰å›æµ‹
- [ ] å®Œæˆå‡å€¼å›å½’ç­–ç•¥ï¼ˆå¸ƒæ—å¸¦ç±»ï¼‰å›æµ‹
- [ ] å®ç°å¤šè‚¡ç¥¨å¹¶è¡Œå›æµ‹æ¡†æ¶

---

## ç¬¬ä¸‰å‘¨ï¼šå› å­ç ”ç©¶å…¥é—¨ + å›æµ‹æ¡†æ¶è¿›é˜¶

### Day 15-17ï¼šAlphaå› å­åŸºç¡€

**å› å­ç ”ç©¶æ ¸å¿ƒæ¦‚å¿µ**ï¼š

```python
import pandas as pd
import numpy as np
from scipy import stats

class FactorAnalyzer:
    """å› å­åˆ†æå·¥å…·"""
    
    def __init__(self, factor_data, return_data, periods=[1, 5, 20]):
        """
        factor_data: DataFrame, index=date, columns=stock_code
        return_data: DataFrame, åŒä¸Šï¼Œå€¼ä¸ºæ”¶ç›Šç‡
        """
        self.factor = factor_data
        self.returns = return_data
        self.periods = periods
    
    def calculate_ic(self, period=1):
        """è®¡ç®—ä¿¡æ¯ç³»æ•°ï¼ˆICï¼‰"""
        ic_series = []
        
        # å¯¹é½å› å­å’Œæœªæ¥æ”¶ç›Š
        future_returns = self.returns.shift(-period)
        
        for date in self.factor.index[:-period]:
            factor_values = self.factor.loc[date].dropna()
            return_values = future_returns.loc[date].dropna()
            
            # å–äº¤é›†
            common = factor_values.index.intersection(return_values.index)
            if len(common) > 30:  # è‡³å°‘30åªè‚¡ç¥¨
                ic, _ = stats.spearmanr(
                    factor_values[common], 
                    return_values[common]
                )
                ic_series.append({'date': date, 'ic': ic})
        
        ic_df = pd.DataFrame(ic_series).set_index('date')
        return ic_df
    
    def ic_summary(self):
        """ICç»Ÿè®¡æ‘˜è¦"""
        results = {}
        for period in self.periods:
            ic_df = self.calculate_ic(period)
            results[f'{period}D'] = {
                'IC_mean': ic_df['ic'].mean(),
                'IC_std': ic_df['ic'].std(),
                'IC_IR': ic_df['ic'].mean() / ic_df['ic'].std(),
                'IC_positive_rate': (ic_df['ic'] > 0).mean()
            }
        return pd.DataFrame(results).T
    
    def factor_quantile_return(self, n_quantiles=5, period=5):
        """åˆ†ä½æ•°ç»„åˆæ”¶ç›Š"""
        quantile_returns = []
        future_returns = self.returns.shift(-period)
        
        for date in self.factor.index[:-period]:
            factor_values = self.factor.loc[date].dropna()
            return_values = future_returns.loc[date].dropna()
            
            common = factor_values.index.intersection(return_values.index)
            if len(common) > n_quantiles * 10:
                # åˆ†ç»„
                quantiles = pd.qcut(factor_values[common], n_quantiles, labels=False)
                
                for q in range(n_quantiles):
                    stocks_in_q = quantiles[quantiles == q].index
                    avg_return = return_values[stocks_in_q].mean()
                    quantile_returns.append({
                        'date': date,
                        'quantile': q + 1,
                        'return': avg_return
                    })
        
        df = pd.DataFrame(quantile_returns)
        return df.groupby('quantile')['return'].mean()
```

**å¸¸è§Alphaå› å­å®ç°**ï¼š

```python
def calculate_factors(df):
    """è®¡ç®—å¸¸è§å› å­"""
    factors = pd.DataFrame(index=df.index)
    
    # 1. åŠ¨é‡å› å­
    factors['mom_20'] = df['close'].pct_change(20)   # 20æ—¥åŠ¨é‡
    factors['mom_60'] = df['close'].pct_change(60)   # 60æ—¥åŠ¨é‡
    
    # 2. åè½¬å› å­
    factors['reversal_5'] = -df['close'].pct_change(5)  # 5æ—¥åè½¬
    
    # 3. æ³¢åŠ¨ç‡å› å­
    factors['volatility'] = df['close'].pct_change().rolling(20).std()
    
    # 4. æ¢æ‰‹ç‡å› å­
    factors['turnover'] = df['volume'] / df['volume'].rolling(20).mean()
    
    # 5. é‡ä»·èƒŒç¦»å› å­
    factors['price_volume_corr'] = df['close'].rolling(20).corr(df['volume'])
    
    # 6. å‡çº¿åç¦»å› å­
    factors['ma_bias'] = df['close'] / df['close'].rolling(20).mean() - 1
    
    # 7. RSIå› å­
    factors['rsi'] = ta.rsi(df['close'], length=14)
    
    # 8. æ³¢åŠ¨ç‡è°ƒæ•´åŠ¨é‡
    factors['vol_adj_mom'] = factors['mom_20'] / factors['volatility']
    
    return factors

# ä½¿ç”¨ç¤ºä¾‹
all_factors = {}
for ts_code in stock_list:
    df = get_stock_data(ts_code)
    all_factors[ts_code] = calculate_factors(df)

# è½¬æ¢ä¸ºé¢æ¿æ•°æ®
factor_panel = pd.concat(all_factors, axis=1)
```

### Day 18-19ï¼šBacktraderè¿›é˜¶

**Backtraderå®Œæ•´ç­–ç•¥æ¡†æ¶**ï¼š

```python
import backtrader as bt
from datetime import datetime

class AdvancedStrategy(bt.Strategy):
    params = (
        ('fast_period', 10),
        ('slow_period', 30),
        ('risk_percent', 0.02),
        ('atr_period', 14),
        ('atr_multiplier', 2),
    )
    
    def __init__(self):
        # æŒ‡æ ‡
        self.fast_ma = bt.indicators.SMA(period=self.p.fast_period)
        self.slow_ma = bt.indicators.SMA(period=self.p.slow_period)
        self.atr = bt.indicators.ATR(period=self.p.atr_period)
        
        # ä¿¡å·
        self.crossover = bt.indicators.CrossOver(self.fast_ma, self.slow_ma)
        
        # è®¢å•è·Ÿè¸ª
        self.order = None
        self.buy_price = None
        self.stop_price = None
    
    def notify_order(self, order):
        """è®¢å•çŠ¶æ€å›è°ƒ"""
        if order.status in [order.Completed]:
            if order.isbuy():
                self.log(f'ä¹°å…¥æ‰§è¡Œ: {order.executed.price:.2f}, '
                        f'æˆæœ¬: {order.executed.value:.2f}, '
                        f'æ‰‹ç»­è´¹: {order.executed.comm:.2f}')
                self.buy_price = order.executed.price
                self.stop_price = self.buy_price - self.atr[0] * self.p.atr_multiplier
            else:
                self.log(f'å–å‡ºæ‰§è¡Œ: {order.executed.price:.2f}, '
                        f'ç›ˆäº: {order.executed.pnl:.2f}')
        
        self.order = None
    
    def notify_trade(self, trade):
        """äº¤æ˜“å®Œæˆå›è°ƒ"""
        if trade.isclosed:
            self.log(f'äº¤æ˜“åˆ©æ¶¦: æ¯›åˆ©={trade.pnl:.2f}, å‡€åˆ©={trade.pnlcomm:.2f}')
    
    def next(self):
        # æœ‰æœªå®Œæˆè®¢å•æ—¶ä¸æ“ä½œ
        if self.order:
            return
        
        # æ›´æ–°ç§»åŠ¨æ­¢æŸ
        if self.position:
            new_stop = self.data.close[0] - self.atr[0] * self.p.atr_multiplier
            if new_stop > self.stop_price:
                self.stop_price = new_stop
            
            # è§¦å‘æ­¢æŸ
            if self.data.close[0] < self.stop_price:
                self.order = self.close()
                return
        
        # å¼€ä»“é€»è¾‘
        if not self.position:
            if self.crossover > 0:  # é‡‘å‰
                # åŸºäºé£é™©è®¡ç®—ä»“ä½
                risk_amount = self.broker.getvalue() * self.p.risk_percent
                stop_distance = self.atr[0] * self.p.atr_multiplier
                size = int(risk_amount / stop_distance)
                
                if size > 0:
                    self.order = self.buy(size=size)
                    self.log(f'ä¹°å…¥ä¿¡å·: ä»·æ ¼={self.data.close[0]:.2f}, æ•°é‡={size}')
        else:
            if self.crossover < 0:  # æ­»å‰
                self.order = self.close()
    
    def log(self, txt, dt=None):
        dt = dt or self.datas[0].datetime.date(0)
        print(f'{dt.isoformat()} {txt}')

# è¿è¡Œå›æµ‹
cerebro = bt.Cerebro()

# æ·»åŠ æ•°æ®
data = bt.feeds.PandasData(
    dataname=df,
    datetime='trade_date',
    open='open',
    high='high',
    low='low',
    close='close',
    volume='vol',
    openinterest=-1
)
cerebro.adddata(data)

# æ·»åŠ ç­–ç•¥
cerebro.addstrategy(AdvancedStrategy)

# è®¾ç½®åˆå§‹èµ„é‡‘
cerebro.broker.setcash(100000)

# è®¾ç½®æ‰‹ç»­è´¹
cerebro.broker.setcommission(commission=0.001)

# æ·»åŠ åˆ†æå™¨
cerebro.addanalyzer(bt.analyzers.SharpeRatio, _name='sharpe')
cerebro.addanalyzer(bt.analyzers.DrawDown, _name='drawdown')
cerebro.addanalyzer(bt.analyzers.TradeAnalyzer, _name='trades')

# è¿è¡Œ
results = cerebro.run()
strat = results[0]

# è¾“å‡ºç»“æœ
print(f"å¤æ™®æ¯”ç‡: {strat.analyzers.sharpe.get_analysis()['sharperatio']:.2f}")
print(f"æœ€å¤§å›æ’¤: {strat.analyzers.drawdown.get_analysis()['max']['drawdown']:.2f}%")

# ç»˜å›¾
cerebro.plot(style='candlestick')
```

### Day 20-21ï¼šç­–ç•¥è¯„ä¼°æŒ‡æ ‡ä½“ç³»

**å®Œæ•´çš„ç­–ç•¥è¯„ä¼°æ¡†æ¶**ï¼š

```python
import numpy as np
import pandas as pd
from scipy import stats

class StrategyEvaluator:
    """ç­–ç•¥è¯„ä¼°å™¨"""
    
    def __init__(self, returns, benchmark_returns=None, risk_free_rate=0.03):
        """
        returns: ç­–ç•¥æ—¥æ”¶ç›Šç‡Series
        benchmark_returns: åŸºå‡†æ”¶ç›Šç‡ï¼ˆå¯é€‰ï¼‰
        risk_free_rate: å¹´åŒ–æ— é£é™©åˆ©ç‡
        """
        self.returns = returns
        self.benchmark = benchmark_returns
        self.rf = risk_free_rate / 252  # æ—¥åŒ–
    
    def total_return(self):
        """æ€»æ”¶ç›Šç‡"""
        return (1 + self.returns).prod() - 1
    
    def annual_return(self):
        """å¹´åŒ–æ”¶ç›Šç‡"""
        total = self.total_return()
        years = len(self.returns) / 252
        return (1 + total) ** (1 / years) - 1
    
    def annual_volatility(self):
        """å¹´åŒ–æ³¢åŠ¨ç‡"""
        return self.returns.std() * np.sqrt(252)
    
    def sharpe_ratio(self):
        """å¤æ™®æ¯”ç‡"""
        excess_return = self.returns - self.rf
        return np.sqrt(252) * excess_return.mean() / excess_return.std()
    
    def sortino_ratio(self):
        """ç´¢æè¯ºæ¯”ç‡ï¼ˆåªæƒ©ç½šä¸‹è¡Œé£é™©ï¼‰"""
        excess_return = self.returns - self.rf
        downside_std = self.returns[self.returns < 0].std()
        return np.sqrt(252) * excess_return.mean() / downside_std
    
    def max_drawdown(self):
        """æœ€å¤§å›æ’¤"""
        cumulative = (1 + self.returns).cumprod()
        running_max = cumulative.cummax()
        drawdown = (cumulative - running_max) / running_max
        return drawdown.min()
    
    def calmar_ratio(self):
        """å¡ç›æ¯”ç‡ï¼ˆå¹´åŒ–æ”¶ç›Š/æœ€å¤§å›æ’¤ï¼‰"""
        return self.annual_return() / abs(self.max_drawdown())
    
    def win_rate(self):
        """èƒœç‡"""
        return (self.returns > 0).mean()
    
    def profit_loss_ratio(self):
        """ç›ˆäºæ¯”"""
        wins = self.returns[self.returns > 0].mean()
        losses = abs(self.returns[self.returns < 0].mean())
        return wins / losses if losses != 0 else np.inf
    
    def var(self, confidence=0.95):
        """VaRï¼ˆé£é™©ä»·å€¼ï¼‰"""
        return np.percentile(self.returns, (1 - confidence) * 100)
    
    def cvar(self, confidence=0.95):
        """CVaRï¼ˆæ¡ä»¶é£é™©ä»·å€¼ï¼‰"""
        var = self.var(confidence)
        return self.returns[self.returns <= var].mean()
    
    def information_ratio(self):
        """ä¿¡æ¯æ¯”ç‡ï¼ˆç›¸å¯¹åŸºå‡†ï¼‰"""
        if self.benchmark is None:
            return None
        active_return = self.returns - self.benchmark
        return np.sqrt(252) * active_return.mean() / active_return.std()
    
    def full_report(self):
        """å®Œæ•´è¯„ä¼°æŠ¥å‘Š"""
        report = {
            'æ€»æ”¶ç›Šç‡': f"{self.total_return():.2%}",
            'å¹´åŒ–æ”¶ç›Šç‡': f"{self.annual_return():.2%}",
            'å¹´åŒ–æ³¢åŠ¨ç‡': f"{self.annual_volatility():.2%}",
            'å¤æ™®æ¯”ç‡': f"{self.sharpe_ratio():.2f}",
            'ç´¢æè¯ºæ¯”ç‡': f"{self.sortino_ratio():.2f}",
            'æœ€å¤§å›æ’¤': f"{self.max_drawdown():.2%}",
            'å¡ç›æ¯”ç‡': f"{self.calmar_ratio():.2f}",
            'èƒœç‡': f"{self.win_rate():.2%}",
            'ç›ˆäºæ¯”': f"{self.profit_loss_ratio():.2f}",
            '95% VaR': f"{self.var():.2%}",
            '95% CVaR': f"{self.cvar():.2%}",
        }
        
        if self.benchmark is not None:
            report['ä¿¡æ¯æ¯”ç‡'] = f"{self.information_ratio():.2f}"
        
        return pd.Series(report)
```

**æœ¬å‘¨äº§å‡ºæ£€æŸ¥æ¸…å•**ï¼š
- [ ] ç†è§£IC/IRç­‰å› å­è¯„ä¼°æŒ‡æ ‡
- [ ] å®ç°3ä¸ªä»¥ä¸ŠAlphaå› å­å¹¶è¿›è¡ŒICåˆ†æ
- [ ] æŒæ¡Backtraderç­–ç•¥å¼€å‘æ¡†æ¶
- [ ] å»ºç«‹å®Œæ•´çš„ç­–ç•¥è¯„ä¼°æŒ‡æ ‡ä½“ç³»

---

## ç¬¬å››å‘¨ï¼šå®æˆ˜æ•´åˆ + QMTå…¥é—¨

### Day 22-24ï¼šå®Œæ•´ç­–ç•¥å¼€å‘æµç¨‹

**ä»æƒ³æ³•åˆ°å›æµ‹çš„æ ‡å‡†æµç¨‹**ï¼š

```python
# strategy_development.py
"""
å®Œæ•´ç­–ç•¥å¼€å‘æ¨¡æ¿
ç­–ç•¥åç§°ï¼šåŠ¨é‡+è´¨é‡åŒå› å­é€‰è‚¡
ç­–ç•¥é€»è¾‘ï¼š
1. æ¯æœˆæœ«é€‰è‚¡
2. ç­›é€‰æ¡ä»¶ï¼š20æ—¥åŠ¨é‡ > 0, ROE > 10%
3. æŒ‰åŠ¨é‡æ’åºï¼Œé€‰å‰20åª
4. ç­‰æƒé‡æŒä»“ï¼Œæœˆåº¦è°ƒä»“
"""

import pandas as pd
import numpy as np
from datetime import datetime, timedelta

class MomentumQualityStrategy:
    def __init__(self, start_date, end_date):
        self.start_date = start_date
        self.end_date = end_date
        self.positions = {}
        self.nav_history = []
        
    def get_universe(self, date):
        """è·å–è‚¡ç¥¨æ± ï¼ˆæ’é™¤STã€åœç‰Œç­‰ï¼‰"""
        # è·å–æ²ªæ·±300æˆåˆ†è‚¡
        hs300 = pro.index_weight(index_code='399300.SZ', 
                                  trade_date=date.strftime('%Y%m%d'))
        return hs300['con_code'].tolist()
    
    def get_factors(self, date, universe):
        """è®¡ç®—å› å­å€¼"""
        factors = []
        
        for stock in universe:
            try:
                # è·å–è¡Œæƒ…æ•°æ®
                df = pro.daily(ts_code=stock, 
                              end_date=date.strftime('%Y%m%d'),
                              limit=60)
                if len(df) < 60:
                    continue
                
                # è·å–è´¢åŠ¡æ•°æ®
                fin = pro.fina_indicator(ts_code=stock, 
                                         end_date=date.strftime('%Y%m%d'),
                                         limit=1)
                
                # è®¡ç®—åŠ¨é‡
                momentum = (df.iloc[0]['close'] / df.iloc[19]['close']) - 1
                
                # è·å–ROE
                roe = fin.iloc[0]['roe'] if len(fin) > 0 else 0
                
                factors.append({
                    'ts_code': stock,
                    'momentum': momentum,
                    'roe': roe,
                    'close': df.iloc[0]['close']
                })
            except:
                continue
        
        return pd.DataFrame(factors)
    
    def select_stocks(self, date):
        """é€‰è‚¡é€»è¾‘"""
        universe = self.get_universe(date)
        factors = self.get_factors(date, universe)
        
        # ç­›é€‰æ¡ä»¶
        filtered = factors[
            (factors['momentum'] > 0) & 
            (factors['roe'] > 10)
        ]
        
        # æ’åºé€‰è‚¡
        selected = filtered.nlargest(20, 'momentum')
        
        return selected['ts_code'].tolist()
    
    def backtest(self):
        """è¿è¡Œå›æµ‹"""
        # ç”Ÿæˆè°ƒä»“æ—¥æœŸï¼ˆæ¯æœˆæœ€åä¸€ä¸ªäº¤æ˜“æ—¥ï¼‰
        trade_dates = pro.trade_cal(
            start_date=self.start_date,
            end_date=self.end_date,
            is_open=1
        )['cal_date'].tolist()
        
        monthly_dates = []
        for i, date in enumerate(trade_dates[:-1]):
            if date[:6] != trade_dates[i+1][:6]:
                monthly_dates.append(date)
        
        # åˆå§‹èµ„é‡‘
        cash = 1000000
        holdings = {}
        nav = cash
        
        for i, date in enumerate(monthly_dates):
            date_dt = datetime.strptime(date, '%Y%m%d')
            
            # é€‰è‚¡
            selected = self.select_stocks(date_dt)
            
            # è®¡ç®—ç­‰æƒé‡ä»“ä½
            weight = 1.0 / len(selected) if selected else 0
            target_value = nav * weight
            
            # æ¨¡æ‹Ÿè°ƒä»“ï¼ˆç®€åŒ–å¤„ç†ï¼‰
            new_holdings = {}
            for stock in selected:
                price = self.get_price(stock, date)
                if price:
                    shares = int(target_value / price / 100) * 100
                    new_holdings[stock] = {'shares': shares, 'price': price}
            
            holdings = new_holdings
            
            # è®°å½•å‡€å€¼
            self.nav_history.append({
                'date': date,
                'nav': nav,
                'n_stocks': len(holdings)
            })
            
            # è®¡ç®—ä¸‹æœŸå‡€å€¼ï¼ˆåˆ°ä¸‹ä¸€ä¸ªè°ƒä»“æ—¥ï¼‰
            if i < len(monthly_dates) - 1:
                next_date = monthly_dates[i + 1]
                nav = self.calculate_nav(holdings, next_date)
        
        return pd.DataFrame(self.nav_history)
    
    def get_price(self, stock, date):
        """è·å–è‚¡ç¥¨ä»·æ ¼"""
        try:
            df = pro.daily(ts_code=stock, trade_date=date)
            return df.iloc[0]['close'] if len(df) > 0 else None
        except:
            return None
    
    def calculate_nav(self, holdings, date):
        """è®¡ç®—ç»„åˆå‡€å€¼"""
        total = 0
        for stock, info in holdings.items():
            price = self.get_price(stock, date)
            if price:
                total += info['shares'] * price
        return total
```

### Day 25-27ï¼šQMTç¯å¢ƒé…ç½®ä¸å…¥é—¨

**QMTå®‰è£…ä¸é…ç½®**ï¼š

1. **å¼€æˆ·å‡†å¤‡**ï¼š
   - é€‰æ‹©æ”¯æŒQMTçš„åˆ¸å•†ï¼ˆæ¨èï¼šå›½é‡‘è¯åˆ¸ã€ä¸œæ–¹è¯åˆ¸ã€é“¶æ²³è¯åˆ¸ç­‰ï¼‰
   - éƒ¨åˆ†åˆ¸å•†æ— èµ„é‡‘é—¨æ§›ï¼Œä½†å»ºè®®è‡³å°‘5ä¸‡ä»¥ä¸Šèµ„é‡‘
   - å¼€æˆ·åè”ç³»å®¢æˆ·ç»ç†å¼€é€šQMTæƒé™

2. **è½¯ä»¶å®‰è£…**ï¼š
   - ä¸‹è½½MiniQMTå®¢æˆ·ç«¯ï¼ˆçº¦500MBï¼‰
   - å®‰è£…ç›®å½•ä¸è¦æœ‰ä¸­æ–‡è·¯å¾„
   - é…ç½®Pythonç¯å¢ƒï¼ˆQMTè‡ªå¸¦Python 3.8ï¼‰

3. **åŸºç¡€ä»£ç æ¡†æ¶**ï¼š

```python
# QMTç­–ç•¥æ¡†æ¶ç¤ºä¾‹
# æ–‡ä»¶ä¿å­˜ä¸º .py æ ¼å¼ï¼Œåœ¨QMTä¸­è¿è¡Œ

def init(context):
    """åˆå§‹åŒ–å‡½æ•°ï¼Œç­–ç•¥å¯åŠ¨æ—¶è°ƒç”¨ä¸€æ¬¡"""
    context.stock_pool = ['000001.SZ', '600000.SH']  # è‚¡ç¥¨æ± 
    context.position_ratio = 0.5  # ä»“ä½æ¯”ä¾‹
    context.ma_period = 20  # å‡çº¿å‘¨æœŸ
    
    # è®¾ç½®å®šæ—¶ä»»åŠ¡
    run_daily(market_open, '09:35')  # æ¯æ—¥å¼€ç›˜åæ‰§è¡Œ
    run_daily(market_close, '14:55')  # æ”¶ç›˜å‰æ‰§è¡Œ

def market_open(context):
    """ç›˜ä¸­ç­–ç•¥é€»è¾‘"""
    for stock in context.stock_pool:
        # è·å–è¡Œæƒ…æ•°æ®
        bars = get_bars(stock, context.ma_period + 5, '1d')
        if bars is None or len(bars) < context.ma_period:
            continue
        
        # è®¡ç®—å‡çº¿
        ma = bars['close'].rolling(context.ma_period).mean()
        current_price = bars['close'].iloc[-1]
        current_ma = ma.iloc[-1]
        
        # è·å–æŒä»“
        position = get_position(stock)
        
        # äº¤æ˜“é€»è¾‘
        if current_price > current_ma:
            if position is None or position.volume == 0:
                # è®¡ç®—å¯ä¹°æ•°é‡
                available_cash = context.portfolio.available_cash
                target_value = available_cash * context.position_ratio
                volume = int(target_value / current_price / 100) * 100
                
                if volume >= 100:
                    order(stock, volume)
                    log.info(f"ä¹°å…¥ {stock}, æ•°é‡: {volume}, ä»·æ ¼: {current_price}")
        
        elif current_price < current_ma:
            if position and position.volume > 0:
                order(stock, -position.volume)
                log.info(f"å–å‡º {stock}, æ•°é‡: {position.volume}, ä»·æ ¼: {current_price}")

def market_close(context):
    """æ”¶ç›˜å‰å¤„ç†"""
    # å¯ä»¥åœ¨è¿™é‡Œåšæ—¥ç»ˆç»Ÿè®¡
    log.info(f"ä»Šæ—¥å‡€å€¼: {context.portfolio.total_value}")

def on_order(context, order):
    """è®¢å•å›è°ƒ"""
    if order.status == 'filled':
        log.info(f"è®¢å•æˆäº¤: {order.stock_code}, {order.direction}, {order.volume}@{order.price}")
    elif order.status == 'rejected':
        log.warning(f"è®¢å•æ‹’ç»: {order.stock_code}, åŸå› : {order.reject_reason}")
```

### Day 28ï¼šç¬¬ä¸€é˜¶æ®µæ€»ç»“ä¸ä¸‹é˜¶æ®µè§„åˆ’

**ç¬¬ä¸€é˜¶æ®µå®Œæˆåº¦æ£€æŸ¥**ï¼š

```markdown
## æŠ€èƒ½æŒæ¡æ¸…å•

### Pythoné‡åŒ–ç¼–ç¨‹ â–¡ å·²æŒæ¡
- [ ] Pandasæ—¶é—´åºåˆ—å¤„ç†
- [ ] NumPyå‘é‡åŒ–è®¡ç®—
- [ ] æŠ€æœ¯æŒ‡æ ‡è®¡ç®—ï¼ˆpandas-taï¼‰
- [ ] æ•°æ®å¯è§†åŒ–ï¼ˆmatplotlib/plotlyï¼‰

### å›æµ‹æ¡†æ¶ â–¡ å·²æŒæ¡
- [ ] Backtesting.pyåŸºç¡€ä½¿ç”¨
- [ ] Backtraderå®Œæ•´ç­–ç•¥å¼€å‘
- [ ] å¤šè‚¡ç¥¨å¹¶è¡Œå›æµ‹
- [ ] ç­–ç•¥è¯„ä¼°æŒ‡æ ‡è®¡ç®—

### æ•°æ®è·å– â–¡ å·²æŒæ¡
- [ ] Tushare Pro Aè‚¡æ•°æ®
- [ ] AKShareæ¸¯è‚¡æ•°æ®
- [ ] è´¢åŠ¡æ•°æ®è·å–
- [ ] æ•°æ®æ¸…æ´—ä¸å­˜å‚¨

### ç­–ç•¥å¼€å‘ â–¡ å·²æŒæ¡
- [ ] è¶‹åŠ¿è·Ÿè¸ªç­–ç•¥
- [ ] å‡å€¼å›å½’ç­–ç•¥
- [ ] æŠ€æœ¯æŒ‡æ ‡ç»„åˆç­–ç•¥
- [ ] å› å­é€‰è‚¡ç­–ç•¥

### å› å­ç ”ç©¶ â–¡ å…¥é—¨
- [ ] IC/IRè®¡ç®—
- [ ] å› å­åˆ†ç»„å›æµ‹
- [ ] å¸¸è§Alphaå› å­

### å®ç›˜å‡†å¤‡ â–¡ å…¥é—¨
- [ ] QMTç¯å¢ƒé…ç½®
- [ ] åŸºç¡€ç­–ç•¥æ¡†æ¶
```

---

## æ¯æ—¥å­¦ä¹ æ—¶é—´åˆ†é…å»ºè®®

å…¨èŒå­¦ä¹ æƒ…å†µä¸‹ï¼Œå»ºè®®æ¯å¤©6-8å°æ—¶ï¼š

| æ—¶é—´æ®µ | å†…å®¹ | æ—¶é•¿ |
|--------|------|------|
| 09:00-10:30 | ç†è®ºå­¦ä¹ ï¼ˆä¹¦ç±/è¯¾ç¨‹ï¼‰ | 1.5h |
| 10:30-12:00 | ä»£ç å®è·µ | 1.5h |
| 14:00-16:00 | é¡¹ç›®å¼€å‘ï¼ˆç­–ç•¥å®ç°ï¼‰ | 2h |
| 16:00-17:30 | æ•°æ®åˆ†æ/å›æµ‹éªŒè¯ | 1.5h |
| 20:00-21:00 | å¤ç›˜æ€»ç»“/ç¤¾åŒºäº¤æµ | 1h |

**æ¨èçš„æ¯æ—¥å¤ç›˜æ¨¡æ¿**ï¼š

```markdown
## æ—¥æœŸï¼šYYYY-MM-DD

### ä»Šæ—¥å­¦ä¹ å†…å®¹
- 

### ä»£ç äº§å‡º
- 

### é‡åˆ°çš„é—®é¢˜
- 

### è§£å†³æ–¹æ¡ˆ
- 

### æ˜æ—¥è®¡åˆ’
- 
```

---

## ç¬¬ä¸€é˜¶æ®µæ¨èèµ„æº

### å¿…è¯»ä¹¦ç±ï¼ˆæŒ‰ä¼˜å…ˆçº§ï¼‰
1. ã€ŠPython for Financeã€‹- Yves Hilpischï¼ˆå…ˆçœ‹å‰5ç« ï¼‰
2. ã€ŠQuantitative Tradingã€‹- Ernest Chanï¼ˆæ‚¨å·²è¯»è¿‡ï¼Œå¯å¤ä¹ ï¼‰
3. ã€Šå› å­æŠ•èµ„ï¼šæ–¹æ³•ä¸å®è·µã€‹- çŸ³å·ï¼ˆAè‚¡å› å­ç ”ç©¶ï¼‰

### åœ¨çº¿èµ„æº
- Tushareå®˜æ–¹æ–‡æ¡£ï¼šhttps://tushare.pro/document/2
- AKShareæ–‡æ¡£ï¼šhttps://akshare.akfamily.xyz/
- Backtraderæ–‡æ¡£ï¼šhttps://www.backtrader.com/docu/
- èšå®½ç¤¾åŒºï¼šhttps://www.joinquant.com/view/community/list

### GitHubé¡¹ç›®ï¼ˆè¾¹å­¦è¾¹çœ‹ï¼‰
- https://github.com/stefan-jansen/machine-learning-for-trading
- https://github.com/vnpy/vnpy
- https://github.com/wilsonfreitas/awesome-quant

---

## ç¬¬äºŒé˜¶æ®µé¢„å‘Šï¼ˆç¬¬2-3ä¸ªæœˆï¼‰

å®Œæˆç¬¬ä¸€é˜¶æ®µåï¼Œç¬¬äºŒé˜¶æ®µå°†é‡ç‚¹ï¼š

1. **vnpyæ¡†æ¶æ·±å…¥** - æ„å»ºå®Œæ•´äº¤æ˜“ç³»ç»Ÿ
2. **å› å­ç ”ç©¶è¿›é˜¶** - å¤šå› å­æ¨¡å‹ã€å› å­åˆæˆ
3. **é£é™©ç®¡ç†ä½“ç³»** - ä»“ä½ç®¡ç†ã€æ­¢æŸç­–ç•¥
4. **QMTå®ç›˜æµ‹è¯•** - æ¨¡æ‹Ÿäº¤æ˜“éªŒè¯
5. **Goè¯­è¨€é‡åŒ–æ¨¡å—** - å¼€å§‹ç”¨Goé‡æ„é«˜æ€§èƒ½ç»„ä»¶

ç¥å­¦ä¹ é¡ºåˆ©ï¼ğŸš€